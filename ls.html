<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&family=Orbitron:wght@400;600&display=swap" rel="stylesheet">
    <title>空降007</title>
    <style>
        /* 开关样式 */
        .switch {
            position: relative;
            display: inline-block;
            width: 56px !important;
            height: 34px;
            margin: 0 !important;
        }
        .switch input { display: none; }
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0; left: 0; right: 0; bottom: 0;
            transition: .3s;
            background: rgba(255,255,255,0.10);
            border: 1px solid rgba(77,210,255,0.24);
            box-shadow: 0 0 0 1px rgba(0,0,0,0.18) inset;
            border-bottom-right-radius: 12px;
            border-top-right-radius: 12px;
        }
        .slider:before {
            position: absolute;
            content: "";
            height: 26px;
            width: 26px;
            left: 3px;
            bottom: 3px;
            background: rgba(236,245,255,0.94);
            transition: .3s;
            border-radius: 50%;
            box-shadow: 0 0 18px rgba(77,210,255,0.20);
        }
        input:checked + .slider {
            background: linear-gradient(135deg, rgba(77,210,255,0.30), rgba(168,85,247,0.18));
            border-color: rgba(77,210,255,0.45);
        }
        input:checked + .slider:before { transform: translateX(24px); }
        .border-right-radius-clear {
            border-bottom-right-radius: 0 !important;
            border-top-right-radius: 0 !important;
        }

        :root {
            --bg0: #05070d;
            --bg1: #080b14;
            --panel: rgba(14, 18, 34, 0.62);
            --panel2: rgba(0, 0, 0, 0.18);
            --text: rgba(236, 245, 255, 0.92);
            --muted: rgba(236, 245, 255, 0.68);
            --border: rgba(77, 210, 255, 0.18);
            --border2: rgba(77, 210, 255, 0.12);
            --glow: rgba(77, 210, 255, 0.35);
            --accentA: rgba(77, 210, 255, 0.95);
            --accentB: rgba(168, 85, 247, 0.90);
            --accentC: rgba(82, 255, 184, 0.85);
            --shadow: rgba(0, 0, 0, 0.65);
        }

        html, body {
            height: 100%;
        }

        body {
            margin: 0;
            padding: 48px 18px 64px;
            align-items: flex-start;
            display: flex;
            justify-content: center;
            font-family: Inter, system-ui, -apple-system, Segoe UI, Arial, sans-serif;
            background:
                radial-gradient(1000px 600px at 20% 10%, rgba(77,210,255,0.20), transparent 55%),
                radial-gradient(900px 520px at 85% 15%, rgba(168,85,247,0.18), transparent 60%),
                radial-gradient(700px 420px at 50% 100%, rgba(82,255,184,0.10), transparent 55%),
                linear-gradient(180deg, var(--bg0), var(--bg1));
            color: var(--text);
            overflow-x: hidden;
            perspective: 900px;
        }

        body::before {
            content: "";
            position: fixed;
            inset: 0;
            pointer-events: none;
            z-index: 2;
            background-image:
                linear-gradient(rgba(77,210,255,0.08) 1px, transparent 1px),
                linear-gradient(90deg, rgba(77,210,255,0.08) 1px, transparent 1px),
                radial-gradient(circle at 50% 50%, rgba(255,255,255,0.06), transparent 55%);
            background-size: 52px 52px, 52px 52px, 100% 100%;
            background-position: 0 0, 0 0, center;
            opacity: 0.55;
            transform: translateZ(0);
            animation: gridFloat 18s linear infinite;
        }

        body::after {
            content: "";
            position: fixed;
            inset: 0;
            pointer-events: none;
            z-index: 3;
            background:
                repeating-linear-gradient(
                    to bottom,
                    rgba(255,255,255,0.02) 0px,
                    rgba(255,255,255,0.02) 1px,
                    transparent 2px,
                    transparent 5px
                );
            mix-blend-mode: overlay;
            opacity: 0.35;
            animation: scanMove 9s linear infinite;
        }

        @keyframes gridFloat {
            0% { transform: translate3d(0, 0, 0); }
            100% { transform: translate3d(0, 52px, 0); }
        }

        @keyframes scanMove {
            0% { background-position: 0 0; }
            100% { background-position: 0 120px; }
        }

        body.intro-lock {
            overflow: hidden;
        }

        body.intro-lock .container {
            opacity: 0;
            pointer-events: none;
        }

        #authOverlay {
            position: fixed;
            inset: 0;
            z-index: 10000;
            display: flex;
            align-items: center;
            justify-content: center;
            background: transparent;
            backdrop-filter: blur(20px) saturate(1.2);
            -webkit-backdrop-filter: blur(20px) saturate(1.2);
            animation: introIn .42s ease both;
        }

        #authGalaxy {
            position: absolute;
            inset: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 0;
        }

        #authFx {
            position: absolute;
            inset: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            opacity: 0.70;
            mix-blend-mode: screen;
            z-index: 2;
        }

        .auth-door {
            position: absolute;
            inset: 0;
            pointer-events: none;
            z-index: 1;
            background:
                radial-gradient(1200px 680px at 50% 40%, rgba(77,210,255,0.06), transparent 60%),
                radial-gradient(1200px 680px at 50% 60%, rgba(168,85,247,0.05), transparent 64%);
        }

        .auth-door::before,
        .auth-door::after {
            display: none;
        }

        .auth-door svg {
            position: absolute;
            left: 50%;
            top: 50%;
            width: min(760px, 92vw);
            height: min(1220px, 92vh);
            transform: translate3d(-50%, -50%, 0);
            opacity: 0.70;
            filter: drop-shadow(0 0 10px rgba(77,210,255,0.08));
        }



        #authOverlay::before {
            content: "";
            position: absolute;
            inset: 0;
            pointer-events: none;
            background:
                repeating-linear-gradient(
                    to bottom,
                    rgba(255,255,255,0.05) 0px,
                    rgba(255,255,255,0.05) 1px,
                    transparent 2px,
                    transparent 7px
                );
            opacity: 0.18;
            mix-blend-mode: overlay;
            animation: introLines 1.8s linear infinite;
        }

        #authOverlay::after {
            content: "";
            position: absolute;
            inset: -18%;
            pointer-events: none;
            background:
                radial-gradient(circle at 35% 20%, rgba(77,210,255,0.12), transparent 50%),
                radial-gradient(circle at 70% 35%, rgba(168,85,247,0.10), transparent 54%);
            opacity: 0.55;
            filter: blur(0.2px);
            animation: introNoise 0.85s steps(2) infinite;
        }

        #authOverlay[data-out="1"] {
            animation: introOut .46s ease both;
        }

        .auth-panel {
            width: min(520px, calc(100% - 32px));
            border-radius: 22px;
            border: 1px solid rgba(77,210,255,0.24);
            background: rgba(6, 8, 16, 0.68);
            box-shadow:
                0 18px 70px rgba(0,0,0,0.74),
                0 0 0 1px rgba(168,85,247,0.10) inset,
                0 0 90px rgba(77,210,255,0.12);
            padding: 18px 18px 16px;
            position: relative;
            overflow: hidden;
            text-align: left;
        }

        .auth-sweep {
            position: absolute;
            inset: 0;
            pointer-events: none;
            z-index: 2;
            opacity: 0.60;
            background: linear-gradient(90deg, transparent, rgba(77,210,255,0.10), rgba(168,85,247,0.08), transparent);
            transform: translateX(-120%);
            animation: authSweep 1.55s ease-in-out infinite;
            mix-blend-mode: screen;
        }

        @keyframes authSweep {
            0% { transform: translateX(-120%); opacity: 0.0; }
            18% { opacity: 0.55; }
            50% { opacity: 0.70; }
            82% { opacity: 0.55; }
            100% { transform: translateX(120%); opacity: 0.0; }
        }

        .auth-panel::before {
            content: "";
            position: absolute;
            inset: -30%;
            opacity: 0.72;
            background:
                radial-gradient(circle at 50% 50%, rgba(77,210,255,0.18), transparent 62%),
                radial-gradient(circle at 50% 50%, rgba(168,85,247,0.12), transparent 70%),
                repeating-linear-gradient(90deg, rgba(255,255,255,0.05) 0px, rgba(255,255,255,0.05) 1px, transparent 2px, transparent 10px),
                repeating-linear-gradient(0deg, rgba(255,255,255,0.04) 0px, rgba(255,255,255,0.04) 1px, transparent 2px, transparent 12px);
            transform: rotate(-10deg);
            mix-blend-mode: screen;
            pointer-events: none;
            animation: introNoise 1.05s steps(2) infinite;
        }

        .auth-panel::after {
            content: "";
            position: absolute;
            inset: 0;
            pointer-events: none;
            background:
                linear-gradient(135deg, rgba(77,210,255,0.14), transparent 45%),
                linear-gradient(315deg, rgba(168,85,247,0.10), transparent 52%);
            opacity: 0.55;
        }

        .auth-hud {
            position: absolute;
            inset: 0;
            pointer-events: none;
            z-index: 1;
            opacity: 0.95;
        }

        .auth-corner {
            position: absolute;
            width: 16px;
            height: 16px;
            border: 2px solid rgba(77,210,255,0.70);
            filter: drop-shadow(0 0 14px rgba(77,210,255,0.18));
        }

        .auth-corner.tl { top: 12px; left: 12px; border-right: 0; border-bottom: 0; }
        .auth-corner.tr { top: 12px; right: 12px; border-left: 0; border-bottom: 0; }
        .auth-corner.bl { bottom: 12px; left: 12px; border-right: 0; border-top: 0; }
        .auth-corner.br { bottom: 12px; right: 12px; border-left: 0; border-top: 0; }

        .auth-core {
            position: absolute;
            left: 50%;
            top: 50%;
            width: 320px;
            height: 320px;
            transform: translate3d(-50%, -50%, 0);
            pointer-events: none;
            border-radius: 999px;
            opacity: 0.55;
            background:
                radial-gradient(circle at 50% 50%, rgba(77,210,255,0.12), transparent 60%),
                radial-gradient(circle at 50% 50%, rgba(168,85,247,0.10), transparent 66%);
            animation: authCore 1.2s ease-in-out infinite;
            filter: drop-shadow(0 0 26px rgba(77,210,255,0.12));
        }

        .auth-core::before {
            content: "";
            position: absolute;
            inset: 26%;
            border-radius: 999px;
            border: 1px solid rgba(77,210,255,0.22);
            box-shadow: 0 0 34px rgba(77,210,255,0.12);
            opacity: 0.85;
        }

        @keyframes authCore {
            0% { transform: translate3d(-50%, -50%, 0) scale(0.97); opacity: 0.45; }
            60% { opacity: 0.66; }
            100% { transform: translate3d(-50%, -50%, 0) scale(1.03); opacity: 0.52; }
        }

        .auth-title {
            font-family: Orbitron, Inter, system-ui, -apple-system, Segoe UI, Arial, sans-serif;
            font-size: 18px;
            letter-spacing: 0.16em;
            color: rgba(236,245,255,0.92);
            position: relative;
            z-index: 1;
        }

        .auth-sub {
            margin-top: 8px;
            font-size: 12px;
            letter-spacing: 0.10em;
            color: rgba(236,245,255,0.64);
            position: relative;
            z-index: 1;
        }

        .auth-chip {
            margin-top: 12px;
            padding: 12px 12px;
            border-radius: 16px;
            border: 1px solid rgba(77,210,255,0.18);
            background: rgba(14, 18, 34, 0.50);
            position: relative;
            z-index: 1;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
        }

        .auth-chip b {
            color: rgba(82,255,184,0.90);
            font-weight: 600;
        }

        .auth-banner {
            margin-top: 12px;
            padding: 10px 12px;
            border-radius: 14px;
            border: 1px solid rgba(77,210,255,0.12);
            background: rgba(0,0,0,0.22);
            color: rgba(236,245,255,0.70);
            font-size: 12px;
            letter-spacing: 0.10em;
            position: relative;
            z-index: 1;
            min-height: 40px;
        }

        .auth-mini {
            margin-top: 8px;
            height: 8px;
            border-radius: 999px;
            background: rgba(255,255,255,0.06);
            border: 1px solid rgba(77,210,255,0.12);
            overflow: hidden;
            position: relative;
        }

        .auth-mini[aria-hidden="true"] {
            display: none;
        }

        .auth-mini i {
            display: block;
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, rgba(82,255,184,0.30), rgba(82,255,184,0.90), rgba(77,210,255,0.70));
            box-shadow: 0 0 18px rgba(82,255,184,0.14);
        }

        .auth-mini b {
            position: absolute;
            right: 8px;
            top: -18px;
            font-family: Orbitron, Inter, system-ui, -apple-system, Segoe UI, Arial, sans-serif;
            font-size: 10px;
            letter-spacing: 0.12em;
            color: rgba(82,255,184,0.92);
            text-shadow: 0 0 14px rgba(82,255,184,0.16);
        }

        .auth-verify {
            margin-top: 14px;
            width: 100% !important;
            height: 52px !important;
            border-radius: 18px !important;
            font-family: Orbitron, Inter, system-ui, -apple-system, Segoe UI, Arial, sans-serif;
            letter-spacing: 0.18em;
            background: linear-gradient(135deg, rgba(77,210,255,0.22), rgba(168,85,247,0.14));
            border: 1px solid rgba(77,210,255,0.32);
            box-shadow:
                0 14px 46px rgba(0,0,0,0.62),
                0 0 38px rgba(77,210,255,0.12);
            position: relative;
        }

        .auth-verify::before {
            content: "";
            position: absolute;
            inset: -2px;
            border-radius: 20px;
            background: conic-gradient(from 180deg, rgba(77,210,255,0.00), rgba(77,210,255,0.45), rgba(168,85,247,0.34), rgba(77,210,255,0.00));
            opacity: 0.55;
            filter: blur(10px);
            animation: authHalo 1.1s linear infinite;
            pointer-events: none;
        }

        @keyframes authHalo {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .auth-welcome {
            position: absolute;
            inset: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 10px;
            opacity: 0;
            pointer-events: none;
            text-align: center;
        }

        #authOverlay[data-state="ok"] .auth-welcome {
            opacity: 1;
            animation: authWelcome 1.15s ease both;
        }

        @keyframes authWelcome {
            0% { transform: translate3d(0, 10px, 0) scale(0.98); opacity: 0; }
            18% { opacity: 1; }
            100% { transform: translate3d(0, 0, 0) scale(1); opacity: 1; }
        }

        #introOverlay {
            position: fixed;
            inset: 0;
            z-index: 9999;
            display: flex;
            align-items: center;
            justify-content: center;
            background:
                radial-gradient(800px 520px at 30% 25%, rgba(77,210,255,0.22), transparent 60%),
                radial-gradient(760px 520px at 70% 20%, rgba(168,85,247,0.18), transparent 58%),
                linear-gradient(180deg, rgba(5,7,13,0.94), rgba(8,11,20,0.92));
            backdrop-filter: blur(18px) saturate(1.2);
            -webkit-backdrop-filter: blur(18px) saturate(1.2);
            animation: introIn .42s ease both;
        }

        #introOverlay[data-active="0"] {
            display: none;
        }

        #introFx {
            position: absolute;
            inset: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            mix-blend-mode: screen;
            opacity: 0.75;
        }

        .intro-radar {
            position: absolute;
            left: 50%;
            top: 50%;
            width: min(820px, 92vw);
            height: min(820px, 92vw);
            transform: translate3d(-50%, -50%, 0);
            border-radius: 999px;
            pointer-events: none;
            opacity: 0.35;
            background:
                radial-gradient(circle at 50% 50%, rgba(77,210,255,0.06), transparent 62%),
                radial-gradient(circle at 50% 50%, transparent 55%, rgba(77,210,255,0.08) 56%, transparent 57%),
                repeating-radial-gradient(circle at 50% 50%, rgba(255,255,255,0.035) 0px, rgba(255,255,255,0.035) 1px, transparent 2px, transparent 16px);
            box-shadow: 0 0 80px rgba(77,210,255,0.06);
            mix-blend-mode: screen;
        }

        .intro-radar::before {
            content: "";
            position: absolute;
            inset: 0;
            border-radius: 999px;
            background: conic-gradient(from 0deg, rgba(77,210,255,0.00), rgba(77,210,255,0.16), rgba(77,210,255,0.00) 70%);
            animation: introRadar 1.7s linear infinite;
        }

        @keyframes introRadar {
            0% { transform: rotate(0deg); opacity: 0.55; }
            100% { transform: rotate(360deg); opacity: 0.55; }
        }

        .intro-granted {
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate3d(-50%, -50%, 0);
            padding: 10px 14px;
            border-radius: 14px;
            border: 1px solid rgba(82,255,184,0.28);
            background: rgba(0,0,0,0.28);
            font-family: Orbitron, Inter, system-ui, -apple-system, Segoe UI, Arial, sans-serif;
            letter-spacing: 0.18em;
            color: rgba(82,255,184,0.94);
            text-shadow: 0 0 18px rgba(82,255,184,0.18);
            opacity: 0;
            pointer-events: none;
            z-index: 3;
        }

        .intro-granted[data-show="1"] {
            animation: introGranted 0.62s ease both;
        }

        @keyframes introGranted {
            0% { opacity: 0; transform: translate3d(-50%, -50%, 0) scale(0.98); }
            18% { opacity: 1; }
            100% { opacity: 0; transform: translate3d(-50%, -52%, 0) scale(1.02); }
        }

        #introOverlay::before {
            content: "";
            position: absolute;
            inset: 0;
            pointer-events: none;
            background:
                repeating-linear-gradient(
                    to bottom,
                    rgba(255,255,255,0.045) 0px,
                    rgba(255,255,255,0.045) 1px,
                    transparent 2px,
                    transparent 7px
                );
            opacity: 0.20;
            mix-blend-mode: overlay;
            animation: introLines 1.9s linear infinite;
        }

        #introOverlay::after {
            content: "";
            position: absolute;
            inset: -18%;
            pointer-events: none;
            background:
                radial-gradient(circle at 35% 20%, rgba(77,210,255,0.10), transparent 50%),
                radial-gradient(circle at 70% 35%, rgba(168,85,247,0.10), transparent 54%);
            opacity: 0.55;
            filter: blur(0.2px);
            animation: introNoise 0.8s steps(2) infinite;
        }

        #introOverlay[data-out="1"] {
            animation: introOut .46s ease both;
        }

        .intro-card {
            width: min(560px, calc(100% - 32px));
            border-radius: 18px;
            border: 1px solid rgba(77,210,255,0.22);
            background: rgba(14, 18, 34, 0.68);
            box-shadow:
                0 14px 54px rgba(0,0,0,0.72),
                0 0 0 1px rgba(168,85,247,0.10) inset,
                0 0 70px rgba(77,210,255,0.14);
            padding: 18px 16px 14px;
            position: relative;
            overflow: hidden;
        }

        .intro-pulse {
            position: absolute;
            left: 50%;
            top: 50%;
            width: 520px;
            height: 520px;
            transform: translate3d(-50%, -50%, 0);
            pointer-events: none;
            border-radius: 999px;
            background:
                radial-gradient(circle at 50% 50%, rgba(77,210,255,0.12), transparent 60%),
                radial-gradient(circle at 50% 50%, rgba(168,85,247,0.10), transparent 66%);
            filter: blur(0.1px);
            opacity: 0.55;
            animation: introPulse 1.05s ease-in-out infinite;
        }

        .intro-pulse::before {
            content: "";
            position: absolute;
            inset: 18%;
            border-radius: 999px;
            border: 1px solid rgba(77,210,255,0.22);
            box-shadow: 0 0 34px rgba(77,210,255,0.12);
            opacity: 0.80;
        }

        .intro-hud {
            position: absolute;
            inset: 0;
            pointer-events: none;
            opacity: 0.95;
        }

        .intro-corner {
            position: absolute;
            width: 14px;
            height: 14px;
            border: 2px solid rgba(77,210,255,0.70);
            filter: drop-shadow(0 0 12px rgba(77,210,255,0.18));
        }

        .intro-corner.tl { top: 10px; left: 10px; border-right: 0; border-bottom: 0; }
        .intro-corner.tr { top: 10px; right: 10px; border-left: 0; border-bottom: 0; }
        .intro-corner.bl { bottom: 10px; left: 10px; border-right: 0; border-top: 0; }
        .intro-corner.br { bottom: 10px; right: 10px; border-left: 0; border-top: 0; }

        .intro-metrics {
            position: absolute;
            top: 10px;
            right: 14px;
            font-family: Orbitron, Inter, system-ui, -apple-system, Segoe UI, Arial, sans-serif;
            font-size: 10px;
            letter-spacing: 0.14em;
            color: rgba(236,245,255,0.62);
            text-transform: uppercase;
            mix-blend-mode: screen;
        }

        .intro-metrics b {
            color: rgba(82,255,184,0.92);
            font-weight: 600;
        }

        .intro-scan {
            position: absolute;
            inset: -40%;
            background:
                radial-gradient(circle at 30% 35%, rgba(77,210,255,0.26), transparent 42%),
                radial-gradient(circle at 70% 30%, rgba(168,85,247,0.22), transparent 45%),
                repeating-linear-gradient(0deg, rgba(255,255,255,0.05) 0px, rgba(255,255,255,0.05) 1px, transparent 2px, transparent 6px);
            opacity: 0.55;
            mix-blend-mode: screen;
            animation: introScan 1.05s linear infinite;
            pointer-events: none;
        }

        .intro-title {
            font-family: Orbitron, Inter, system-ui, -apple-system, Segoe UI, Arial, sans-serif;
            font-size: 28px;
            letter-spacing: 0.22em;
            text-transform: uppercase;
            color: rgba(236,245,255,0.94);
            text-shadow:
                0 0 16px rgba(77,210,255,0.22),
                0 0 26px rgba(168,85,247,0.14);
            position: relative;
            z-index: 1;
        }

        .intro-title[data-glitch="1"]::before,
        .intro-title[data-glitch="1"]::after {
            content: attr(data-text);
            position: absolute;
            left: 0;
            top: 0;
            opacity: 0.70;
            z-index: -1;
            pointer-events: none;
        }

        .intro-title[data-glitch="1"]::before {
            color: rgba(77,210,255,0.92);
            transform: translate3d(-1px, 0, 0);
            clip-path: inset(0 0 52% 0);
            animation: introGlitchA 0.18s steps(2) infinite;
        }

        .intro-title[data-glitch="1"]::after {
            color: rgba(168,85,247,0.86);
            transform: translate3d(1px, 0, 0);
            clip-path: inset(48% 0 0 0);
            animation: introGlitchB 0.16s steps(2) infinite;
        }

        .intro-sub {
            margin-top: 8px;
            font-size: 13px;
            color: rgba(236,245,255,0.68);
            letter-spacing: 0.10em;
            position: relative;
            z-index: 1;
        }

        .intro-bar {
            height: 6px;
            border-radius: 999px;
            margin-top: 14px;
            background: rgba(255,255,255,0.08);
            border: 1px solid rgba(77,210,255,0.18);
            overflow: hidden;
            position: relative;
            z-index: 1;
        }

        .intro-bar > i {
            display: block;
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, rgba(77,210,255,0.20), rgba(77,210,255,0.85), rgba(168,85,247,0.65));
            filter: drop-shadow(0 0 10px rgba(77,210,255,0.22));
            box-shadow: 0 0 20px rgba(77,210,255,0.10);
        }

        #introSkip {
            margin-top: 12px;
            height: 34px;
            width: auto;
            padding: 0 12px;
            border-radius: 12px;
            font-size: 12px;
            background: rgba(0,0,0,0.20);
            border: 1px solid rgba(77,210,255,0.18);
        }

        .intro-log {
            margin-top: 10px;
            padding: 10px 10px;
            border-radius: 12px;
            text-align: left;
            background: rgba(0,0,0,0.22);
            border: 1px solid rgba(77,210,255,0.12);
            font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
            font-size: 11px;
            line-height: 1.4;
            color: rgba(236,245,255,0.72);
            max-height: 86px;
            overflow: hidden;
            position: relative;
            z-index: 1;
        }

        .intro-caret {
            display: inline-block;
            width: 8px;
            height: 12px;
            margin-left: 2px;
            background: rgba(82,255,184,0.88);
            box-shadow: 0 0 14px rgba(82,255,184,0.18);
            animation: introCaret 0.62s steps(2) infinite;
            vertical-align: -2px;
        }

        @keyframes introIn {
            from { opacity: 0; transform: translate3d(0, 10px, 0); }
            to { opacity: 1; transform: translate3d(0, 0, 0); }
        }

        @keyframes introOut {
            from { opacity: 1; transform: translate3d(0, 0, 0); }
            to { opacity: 0; transform: translate3d(0, -10px, 0); }
        }

        @keyframes introPulse {
            0% { transform: translate3d(-50%, -50%, 0) scale(0.96); opacity: 0.45; }
            60% { opacity: 0.66; }
            100% { transform: translate3d(-50%, -50%, 0) scale(1.02); opacity: 0.50; }
        }

        @keyframes introScan {
            0% { transform: translate3d(0, 0, 0) rotate(0deg); }
            100% { transform: translate3d(0, 40px, 0) rotate(1deg); }
        }

        @keyframes introLoad {
            0% { opacity: 0.45; }
            50% { opacity: 1; }
            100% { opacity: 0.65; }
        }

        @keyframes introLines {
            0% { background-position: 0 0; opacity: 0.18; }
            50% { opacity: 0.24; }
            100% { background-position: 0 180px; opacity: 0.18; }
        }

        @keyframes introNoise {
            0% { transform: translate3d(0, 0, 0) rotate(0deg); opacity: 0.45; }
            100% { transform: translate3d(12px, -18px, 0) rotate(0.8deg); opacity: 0.65; }
        }

        @keyframes introGlitchA {
            0% { transform: translate3d(-1px, 0, 0); }
            100% { transform: translate3d(-3px, 0, 0); }
        }

        @keyframes introGlitchB {
            0% { transform: translate3d(1px, 0, 0); }
            100% { transform: translate3d(3px, 0, 0); }
        }

        @keyframes introCaret {
            0% { opacity: 0; }
            100% { opacity: 1; }
        }

        @media (prefers-reduced-motion: reduce) {
            #introOverlay,
            #introOverlay * {
                animation: none !important;
                transition: none !important;
            }
        }

        .container {
            width: min(760px, 100%);
            padding: 22px 18px 16px;
            text-align: center;
            background: var(--panel);
            border-radius: 18px;
            border: 1px solid var(--border);
            box-shadow:
                0 12px 45px var(--shadow),
                0 0 0 1px rgba(168,85,247,0.10) inset,
                0 0 60px rgba(77,210,255,0.10);
            backdrop-filter: blur(16px) saturate(1.2);
            -webkit-backdrop-filter: blur(16px) saturate(1.2);
            position: relative;
            z-index: 4;
            overflow: hidden;
            transform-style: preserve-3d;
            transition: transform .22s ease, box-shadow .22s ease;
            will-change: transform;
        }

        .container:hover:not([data-tilt="1"]) {
            transform: none;
            box-shadow:
                0 14px 52px var(--shadow),
                0 0 0 1px rgba(168,85,247,0.12) inset,
                0 0 90px rgba(77,210,255,0.12);
        }

        .container[data-tilt="1"] {
            transform: none;
        }

        .container:focus-within {
            transform: none;
        }

        .container::before {
            content: "";
            position: absolute;
            inset: -2px;
            background: linear-gradient(135deg, rgba(77,210,255,0.45), rgba(168,85,247,0.42), rgba(82,255,184,0.24));
            filter: blur(18px);
            opacity: 0.55;
            z-index: 0;
        }

        .container::after {
            content: "";
            position: absolute;
            inset: 0;
            background:
                linear-gradient(180deg, rgba(255,255,255,0.06), transparent 24%),
                radial-gradient(900px 260px at 50% 0%, rgba(77,210,255,0.12), transparent 55%);
            opacity: 0.85;
            z-index: 0;
        }

        .container > * {
            position: relative;
            z-index: 1;
        }

        .app-header {
            margin-bottom: 14px;
            text-align: left;
            padding: 14px 14px 12px;
            border-radius: 14px;
            background: var(--panel2);
            border: 1px solid var(--border2);
            position: relative;
        }

        .app-head-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
        }

        .app-head-actions {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .guide-btn {
            position: relative;
            height: 32px !important;
            width: auto !important;
            padding: 0 14px !important;
            border-radius: 12px !important;
            font-size: 12px !important;
            white-space: nowrap;
            min-width: 110px;
            flex: 0 0 auto;
        }

        .guide-btn[data-tip] {
            width: auto !important;
            padding-right: 10px !important;
        }

        .guide-btn[data-tip]::after {
            display: none;
        }

        .guide-modal {
            position: fixed;
            inset: 0;
            display: none;
            z-index: 10000;
        }

        .guide-modal[data-open="true"] {
            display: block;
        }

        .guide-backdrop {
            position: absolute;
            inset: 0;
            background: rgba(2, 4, 10, 0.55);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
        }

        .guide-dialog {
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            width: min(680px, calc(100vw - 24px));
            max-height: min(74vh, 720px);
            overflow: auto;
            border-radius: 16px;
            background: rgba(10, 12, 22, 0.78);
            border: 1px solid rgba(77,210,255,0.18);
            box-shadow: 0 18px 70px rgba(0,0,0,0.65), 0 0 0 1px rgba(0,0,0,0.22) inset;
            padding: 14px 14px 12px;
        }

        .guide-head {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
            margin-bottom: 10px;
        }

        .guide-title {
            font-family: Orbitron, Inter, system-ui, -apple-system, Segoe UI, Arial, sans-serif;
            font-size: 13px;
            letter-spacing: 0.18em;
            color: rgba(236,245,255,0.92);
        }

        .guide-close {
            height: 32px !important;
            width: auto !important;
            padding: 0 10px !important;
            border-radius: 12px !important;
            font-size: 12px !important;
        }

        .guide-steps {
            margin: 0;
            padding: 0 0 0 18px;
            color: rgba(236,245,255,0.82);
            font-size: 12px;
            line-height: 1.6;
        }

        .guide-steps li {
            margin: 8px 0;
        }

        body.guide-open {
            overflow: hidden;
        }

        .app-title {
            font-family: Orbitron, Inter, system-ui, -apple-system, Segoe UI, Arial, sans-serif;
            font-size: 18px;
            letter-spacing: 0.18em;
            text-transform: uppercase;
            color: rgba(236, 245, 255, 0.95);
            text-shadow: 0 0 18px rgba(77,210,255,0.18);
            position: relative;
        }

        .app-title::before,
        .app-title::after {
            content: attr(data-text);
            position: absolute;
            inset: 0;
            pointer-events: none;
            opacity: 0;
        }

        .app-title::before {
            color: rgba(77,210,255,0.75);
            transform: translate3d(1px, 0, 0);
            mix-blend-mode: screen;
        }

        .app-title::after {
            color: rgba(168,85,247,0.70);
            transform: translate3d(-1px, 0, 0);
            mix-blend-mode: screen;
        }

        .container:hover .app-title::before,
        .container:hover .app-title::after {
            opacity: 0.55;
            animation: glitchJitter 1.7s infinite;
        }

        @keyframes glitchJitter {
            0%, 100% { clip-path: inset(0 0 85% 0); transform: translate3d(1px, 0, 0); }
            10% { clip-path: inset(10% 0 62% 0); transform: translate3d(-1px, 0, 0); }
            20% { clip-path: inset(35% 0 45% 0); transform: translate3d(2px, 0, 0); }
            30% { clip-path: inset(58% 0 22% 0); transform: translate3d(-2px, 0, 0); }
            40% { clip-path: inset(72% 0 10% 0); transform: translate3d(1px, 0, 0); }
            55% { clip-path: inset(18% 0 60% 0); transform: translate3d(-1px, 0, 0); }
            70% { clip-path: inset(42% 0 36% 0); transform: translate3d(2px, 0, 0); }
            85% { clip-path: inset(6% 0 78% 0); transform: translate3d(-2px, 0, 0); }
        }

        .app-subtitle {
            margin-top: 6px;
            font-size: 12px;
            color: var(--muted);
            letter-spacing: 0.06em;
            line-height: 1.4;
        }

        .app-meta {
            margin-top: 8px;
            font-size: 12px;
            color: rgba(236,245,255,0.70);
            letter-spacing: 0.04em;
        }

        .app-meta strong {
            color: rgba(236,245,255,0.88);
            font-weight: 600;
        }

        .hud-section {
            margin: 12px 2px 8px;
            padding: 10px 12px;
            border-radius: 14px;
            background: rgba(0,0,0,0.14);
            border: 1px solid rgba(77,210,255,0.12);
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
            text-align: left;
            transform: translateZ(10px);
        }

        .hud-kicker {
            font-family: Orbitron, Inter, system-ui, -apple-system, Segoe UI, Arial, sans-serif;
            font-size: 11px;
            letter-spacing: 0.18em;
            text-transform: uppercase;
            color: rgba(236,245,255,0.86);
            white-space: nowrap;
        }

        .hud-kicker em {
            font-style: normal;
            color: rgba(77,210,255,0.88);
        }

        .hud-line {
            height: 1px;
            flex: 1;
            background: linear-gradient(90deg, rgba(77,210,255,0.35), rgba(168,85,247,0.20), transparent);
            opacity: 0.9;
        }

        .hud-tag {
            font-family: Orbitron, Inter, system-ui, -apple-system, Segoe UI, Arial, sans-serif;
            font-size: 10px;
            letter-spacing: 0.16em;
            text-transform: uppercase;
            color: rgba(236,245,255,0.62);
            border: 1px solid rgba(77,210,255,0.14);
            background: rgba(77,210,255,0.06);
            padding: 6px 8px;
            border-radius: 999px;
            white-space: nowrap;
        }

        .hud-tag.hud-toggle {
            cursor: pointer;
            user-select: none;
        }

        .hud-tag.hud-toggle[aria-pressed="true"] {
            border-color: rgba(255, 88, 122, 0.38);
            background: rgba(255, 88, 122, 0.10);
            color: rgba(255, 206, 214, 0.82);
        }

        .section-body[data-collapsed="true"] {
            display: none;
        }

        .hud-tag[data-tip] {
            position: relative;
            padding-right: 8px;
            cursor: help;
        }

        .hud-tag[data-tip]::after {
            display: none;
        }

        .input-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            margin-bottom: 12px;
            padding: 10px 10px;
            border-radius: 14px;
            background: var(--panel2);
            border: 1px solid rgba(77,210,255,0.10);
            flex-wrap: wrap;
        }

        .input-group input,
        .input-group button {
            pointer-events: auto;
        }

        .input-group button {
            position: relative;
            z-index: 2;
        }

        .input-group label {
            width: 86px;
            color: rgba(236,245,255,0.78);
            font-size: 12px;
            letter-spacing: 0.08em;
            font-family: Orbitron, Inter, system-ui, -apple-system, Segoe UI, Arial, sans-serif;
        }

        .input-group label[data-tip] {
            position: relative;
            padding-right: 0;
            cursor: help;
        }

        .input-group label[data-tip]::after {
            display: none;
        }

        .start-group {
            border: 1px solid rgba(77,210,255,0.12);
            border-radius: 16px;
            padding: 10px 10px;
            margin-bottom: 14px;
            background: rgba(0,0,0,0.16);
        }

        .container input[type="text"],
        .container input[type="number"],
        .container input[type="datetime-local"] {
            padding: 9px 10px !important;
            border: 1px solid rgba(77,210,255,0.22) !important;
            border-radius: 12px !important;
            background: rgba(7, 10, 18, 0.55) !important;
            color: var(--text) !important;
            box-shadow: 0 0 0 1px rgba(0,0,0,0.25) inset;
            transition: border-color .18s ease, box-shadow .18s ease, transform .18s ease;
            max-width: 100%;
        }

        .container input[type="number"]::-webkit-outer-spin-button,
        .container input[type="number"]::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        .container input[type="number"] {
            appearance: textfield;
            -moz-appearance: textfield;
        }

        .container input[type="text"]::placeholder,
        .container input[type="datetime-local"]::placeholder {
            color: rgba(236,245,255,0.42);
        }

        .container input.is-invalid {
            border-color: rgba(255, 88, 122, 0.70) !important;
            box-shadow: 0 0 0 3px rgba(255, 88, 122, 0.18), 0 0 26px rgba(255, 88, 122, 0.10) !important;
        }

        .container input[type="text"]:focus,
        .container input[type="datetime-local"]:focus {
            outline: none;
            border-color: rgba(77,210,255,0.55) !important;
            box-shadow: 0 0 0 3px rgba(77,210,255,0.18), 0 0 24px rgba(77,210,255,0.12);
            transform: translateY(-1px);
        }

        .container input[disabled] {
            opacity: 0.75;
            cursor: not-allowed;
        }

        .container button {
            height: 34px !important;
            width: 36px !important;
            border-radius: 12px !important;
            border: 1px solid rgba(77,210,255,0.30) !important;
            background: linear-gradient(135deg, rgba(77,210,255,0.18), rgba(168,85,247,0.14)) !important;
            color: rgba(236,245,255,0.92) !important;
            box-shadow: 0 0 0 1px rgba(0,0,0,0.22) inset, 0 8px 24px rgba(0,0,0,0.35);
            cursor: pointer;
            transition: transform .16s ease, box-shadow .16s ease, border-color .16s ease, background .16s ease;
            position: relative;
            overflow: hidden;
            isolation: isolate;
        }

        .container button[data-tip] {
            padding-right: 0 !important;
        }

        .container button[data-tip]::after {
            display: none;
        }

        #neoTooltip {
            position: fixed;
            left: 0;
            top: 0;
            transform: translate3d(-9999px, -9999px, 0);
            padding: 10px 12px;
            border-radius: 12px;
            max-width: min(320px, calc(100vw - 24px));
            background: rgba(10, 12, 22, 0.72);
            border: 1px solid rgba(77,210,255,0.22);
            box-shadow:
                0 14px 45px rgba(0,0,0,0.55),
                0 0 0 1px rgba(0,0,0,0.22) inset,
                0 0 36px rgba(77,210,255,0.14);
            color: rgba(236,245,255,0.92);
            font-size: 12px;
            line-height: 1.45;
            letter-spacing: 0.02em;
            backdrop-filter: blur(14px) saturate(1.25);
            -webkit-backdrop-filter: blur(14px) saturate(1.25);
            opacity: 0;
            transition: opacity .12s ease;
            pointer-events: none;
            z-index: 9999;
        }

        #neoTooltip[data-show="true"] {
            opacity: 1;
        }

        #neoToast {
            position: fixed;
            left: 50%;
            bottom: 18px;
            transform: translate3d(-50%, 0, 0);
            padding: 10px 12px;
            border-radius: 12px;
            background: rgba(10, 12, 22, 0.78);
            border: 1px solid rgba(77,210,255,0.22);
            box-shadow: 0 12px 40px rgba(0,0,0,0.55), 0 0 30px rgba(77,210,255,0.12);
            color: rgba(236,245,255,0.92);
            font-size: 12px;
            letter-spacing: 0.02em;
            opacity: 0;
            pointer-events: none;
            transition: opacity .14s ease;
            z-index: 9999;
        }

        #neoToast[data-show="true"] {
            opacity: 1;
        }

        #neoTooltip::before {
            content: "";
            position: absolute;
            inset: -2px;
            border-radius: 14px;
            background: linear-gradient(135deg, rgba(77,210,255,0.35), rgba(168,85,247,0.28), rgba(82,255,184,0.18));
            filter: blur(16px);
            opacity: 0.5;
            z-index: -1;
        }

        #neoTooltip::after {
            content: "";
            position: absolute;
            left: var(--arrowX, 16px);
            bottom: -6px;
            width: 12px;
            height: 12px;
            background: rgba(10, 12, 22, 0.72);
            border-left: 1px solid rgba(77,210,255,0.18);
            border-bottom: 1px solid rgba(77,210,255,0.18);
            transform: rotate(-45deg);
        }

        #neoTooltip[data-place="bottom"]::after {
            top: -6px;
            bottom: auto;
            border-left: 1px solid rgba(77,210,255,0.18);
            border-bottom: 0;
            border-top: 1px solid rgba(77,210,255,0.18);
            transform: rotate(135deg);
        }

        #starfield {
            position: fixed;
            inset: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 0;
            opacity: 0.65;
        }

        #cursorGlow {
            position: fixed;
            inset: 0;
            pointer-events: none;
            z-index: 1;
            opacity: 0.85;
        }

        #cursorGlow::before {
            content: "";
            position: absolute;
            left: var(--cgx, -9999px);
            top: var(--cgy, -9999px);
            width: 420px;
            height: 420px;
            transform: translate3d(-50%, -50%, 0);
            background: radial-gradient(circle at center, rgba(77,210,255,0.18), rgba(168,85,247,0.10) 35%, transparent 70%);
            filter: blur(2px);
            mix-blend-mode: screen;
        }

        .container button::before {
            content: "";
            position: absolute;
            top: -40%;
            left: -120%;
            width: 90%;
            height: 180%;
            background: linear-gradient(90deg, transparent, rgba(77,210,255,0.65), rgba(168,85,247,0.50), transparent);
            transform: skewX(-22deg);
            opacity: 0;
            pointer-events: none;
            mix-blend-mode: screen;
        }

        .container button:hover::before {
            opacity: 0.9;
            animation: btnSweep 1.05s ease-out 1;
        }

        .container button:focus-visible {
            outline: none;
            border-color: rgba(77,210,255,0.70) !important;
            box-shadow: 0 0 0 3px rgba(77,210,255,0.22), 0 0 0 1px rgba(0,0,0,0.22) inset, 0 0 24px rgba(77,210,255,0.16);
        }

        .container button:focus-visible::before {
            opacity: 0.9;
            animation: btnSweep 1.05s ease-out 1;
        }

        @keyframes btnSweep {
            0% { left: -120%; }
            100% { left: 140%; }
        }

        .container button:hover {
            transform: translateY(-1px);
            border-color: rgba(77,210,255,0.55) !important;
            box-shadow: 0 0 0 1px rgba(0,0,0,0.20) inset, 0 10px 28px rgba(0,0,0,0.45), 0 0 24px rgba(77,210,255,0.10);
        }

        .container button:active {
            transform: translateY(0px) scale(0.98);
        }

        .container button:disabled {
            opacity: 0.45;
            cursor: not-allowed;
        }

        .container button:disabled::before {
            opacity: 0 !important;
            animation: none !important;
        }

        input[type="range"] {
            accent-color: rgba(77,210,255,0.85);
        }

        input[type="range"] {
            height: 24px;
            background: transparent;
        }

        input[type="range"]::-webkit-slider-runnable-track {
            height: 6px;
            border-radius: 999px;
            background: linear-gradient(90deg, rgba(77,210,255,0.40), rgba(168,85,247,0.26));
            box-shadow: 0 0 0 1px rgba(0,0,0,0.26) inset;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            margin-top: -5px;
            border-radius: 50%;
            background: rgba(236,245,255,0.92);
            border: 1px solid rgba(77,210,255,0.45);
            box-shadow: 0 0 18px rgba(77,210,255,0.22);
        }

        input[type="range"]::-moz-range-track {
            height: 6px;
            border-radius: 999px;
            background: linear-gradient(90deg, rgba(77,210,255,0.40), rgba(168,85,247,0.26));
            box-shadow: 0 0 0 1px rgba(0,0,0,0.26) inset;
        }

        input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: rgba(236,245,255,0.92);
            border: 1px solid rgba(77,210,255,0.45);
            box-shadow: 0 0 18px rgba(77,210,255,0.22);
        }

        #horizontalValue {
            color: rgba(236,245,255,0.82) !important;
            letter-spacing: 0.06em;
        }

        #attackCanvas {
            border: 1px solid rgba(77,210,255,0.22) !important;
            border-radius: 16px;
            background: rgba(0,0,0,0.20);
            box-shadow: 0 0 0 1px rgba(0,0,0,0.25) inset, 0 12px 32px rgba(0,0,0,0.45);
            margin: 0 auto !important;
            display: block !important;
            touch-action: none;
            cursor: grab;
            /* 二维回退时，也尽量有更大的预览面积 */
            width: clamp(360px, 52vw, 560px) !important;
            height: clamp(360px, 52vw, 560px) !important;
        }

        #attackCanvasFx {
            position: absolute;
            left: 50%;
            top: 12px;
            transform: translate3d(-50%, 0, 0);
            pointer-events: none;
            border-radius: 16px;
            width: clamp(360px, 52vw, 560px) !important;
            height: clamp(360px, 52vw, 560px) !important;
            mix-blend-mode: screen;
            opacity: 0.95;
        }

        .container.is-3d #attackCanvasFx {
            display: none !important;
        }

        .container.is-3d #attackCanvas {
            cursor: default;
        }

        #attack3D {
            width: clamp(360px, 52vw, 560px);
            height: clamp(360px, 52vw, 560px);
            display: none;
        }

        .container.is-3d #attackCanvas {
            display: none !important;
        }

        .container.is-3d #attack3D {
            display: block;
        }

        #attack3D canvas {
            width: 100% !important;
            height: 100% !important;
            display: block;
            border: 1px solid rgba(77,210,255,0.22);
            border-radius: 16px;
            background: rgba(0,0,0,0.20);
            box-shadow: 0 0 0 1px rgba(0,0,0,0.25) inset, 0 12px 32px rgba(0,0,0,0.45);
        }

        .preview-actions {
            position: absolute;
            right: 12px;
            top: 12px;
            display: flex;
            gap: 8px;
            z-index: 12;
        }

        .preview-actions button {
            width: auto !important;
            padding: 0 10px !important;
            height: 32px !important;
            font-size: 12px !important;
        }

        .preview-actions button[data-tip] {
            width: auto !important;
            padding-right: 10px !important;
        }

        .preview-actions button[data-tip]::after {
            display: none;
        }

        .canvas-shell {
            position: relative;
            margin: 18px auto;
            padding: 12px;
            width: fit-content;
            max-width: 100%;
            border-radius: 20px;
            background: rgba(0,0,0,0.14);
            border: 1px solid rgba(77,210,255,0.14);
            box-shadow:
                0 0 0 1px rgba(0,0,0,0.25) inset,
                0 18px 50px rgba(0,0,0,0.55),
                0 0 36px rgba(77,210,255,0.10);
            transform: translateZ(14px);
            box-sizing: border-box;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .canvas-shell::before {
            content: "";
            position: absolute;
            inset: 6px;
            border-radius: 16px;
            pointer-events: none;
            background:
                radial-gradient(420px 240px at 50% 0%, rgba(77,210,255,0.10), transparent 60%),
                linear-gradient(180deg, rgba(255,255,255,0.04), transparent 40%);
            opacity: 0.9;
        }

        .canvas-shell::after {
            content: "";
            position: absolute;
            inset: 0;
            border-radius: 20px;
            pointer-events: none;
            background:
                linear-gradient(var(--accentA), var(--accentA)) left 10px top 10px/18px 2px no-repeat,
                linear-gradient(var(--accentA), var(--accentA)) left 10px top 10px/2px 18px no-repeat,
                linear-gradient(var(--accentB), var(--accentB)) right 10px top 10px/18px 2px no-repeat,
                linear-gradient(var(--accentB), var(--accentB)) right 10px top 10px/2px 18px no-repeat,
                linear-gradient(var(--accentC), var(--accentC)) left 10px bottom 10px/18px 2px no-repeat,
                linear-gradient(var(--accentC), var(--accentC)) left 10px bottom 10px/2px 18px no-repeat,
                linear-gradient(rgba(236,245,255,0.55), rgba(236,245,255,0.55)) right 10px bottom 10px/18px 2px no-repeat,
                linear-gradient(rgba(236,245,255,0.55), rgba(236,245,255,0.55)) right 10px bottom 10px/2px 18px no-repeat;
            opacity: 0.85;
            filter: drop-shadow(0 0 12px rgba(77,210,255,0.10));
            animation: hudPulse 3.2s ease-in-out infinite;
        }

        @keyframes hudPulse {
            0%, 100% { opacity: 0.72; }
            50% { opacity: 0.95; }
        }

        #sentryTimeText {
            color: rgba(77,210,255,0.92);
            text-shadow: 0 0 14px rgba(77,210,255,0.16);
            font-variant-numeric: tabular-nums;
        }

        .app-header,
        .app-footer,
        .input-group,
        .start-group,
        #resultContainer {
            transform: translateZ(10px);
        }

        .input-group:hover,
        .start-group:hover,
        #resultContainer:hover {
            border-color: rgba(77,210,255,0.18);
            box-shadow: 0 0 0 1px rgba(77,210,255,0.08) inset;
        }

        #resultContainer {
            margin-top: 16px !important;
            padding: 12px 12px;
            border-radius: 14px;
            background: rgba(0,0,0,0.16);
            border: 1px solid rgba(77,210,255,0.10);
            position: relative;
        }

        .result-actions {
            position: absolute;
            left: 0;
            top: 0;
            transform: translate3d(-9999px, -9999px, 0);
            opacity: 0;
            display: flex;
            gap: 8px;
            padding: 8px;
            border-radius: 14px;
            background: rgba(10, 12, 22, 0.62);
            border: 1px solid rgba(77,210,255,0.14);
            backdrop-filter: blur(14px) saturate(1.2);
            -webkit-backdrop-filter: blur(14px) saturate(1.2);
            box-shadow: 0 12px 40px rgba(0,0,0,0.55);
            pointer-events: auto;
            z-index: 9;
            transition: opacity .14s ease;
        }

        .result-actions button {
            width: auto !important;
            padding: 0 10px !important;
            font-size: 12px !important;
            height: 32px !important;
            border-radius: 12px !important;
        }

        #resultContainer .result-actions button[data-tip] {
            width: auto !important;
            padding-right: 10px !important;
        }

        #resultContainer .result-actions button::after {
            display: none;
        }

        .result-actions[data-show="true"] {
            opacity: 1;
        }

        #resultContainer table {
            border-collapse: separate;
            border-spacing: 0;
            overflow: hidden;
        }

        #resultContainer th,
        #resultContainer td {
            padding: 10px 10px;
            font-size: 12px;
            color: rgba(236,245,255,0.86);
            border-bottom: 1px solid rgba(77,210,255,0.12);
        }

        #resultContainer thead th {
            color: rgba(236,245,255,0.92);
            letter-spacing: 0.10em;
            background: rgba(77,210,255,0.06);
        }

        #resultContainer tbody tr:hover td {
            background: rgba(77,210,255,0.06);
        }

        .res-queueName {
            color: rgba(82,255,184,0.85);
        }

        .app-footer {
            margin-top: 14px;
            padding: 10px 12px;
            border-radius: 14px;
            background: rgba(0,0,0,0.14);
            border: 1px solid rgba(77,210,255,0.10);
            color: rgba(236,245,255,0.62);
            font-size: 12px;
            letter-spacing: 0.06em;
            text-align: left;
        }

        .app-footer strong {
            color: rgba(236,245,255,0.86);
            font-weight: 600;
        }

        @supports not ((-webkit-backdrop-filter: blur(1px)) or (backdrop-filter: blur(1px))) {
            .container {
                background: rgba(14, 18, 34, 0.88);
            }
        }

        @media (prefers-reduced-motion: reduce) {
            body::before,
            body::after {
                animation: none;
            }

            .container button,
            .container input[type="text"],
            .container input[type="datetime-local"] {
                transition: none;
            }

            .container:hover {
                transform: none;
            }

            .container button:hover::before {
                animation: none;
            }

            .canvas-shell::after {
                animation: none;
            }

            #cursorGlow {
                display: none;
            }
        }

        @media (hover: none) {
            .container:hover {
                transform: none;
            }

            .container button:hover::before {
                opacity: 0;
                animation: none;
            }

        }

        /* 仅在纯触摸设备上隐藏悬浮提示，避免部分触控电脑/浏览器误判 hover 导致桌面端提示失效 */
        @media (hover: none) and (pointer: coarse) {
            #neoTooltip {
                display: none;
            }

            /* 移动端：减少 3D 合成层导致的点击偏移/无响应风险 */
            .container {
                transform-style: flat !important;
                will-change: auto !important;
            }

            .app-header,
            .hud-section,
            .input-group,
            .start-group,
            #resultContainer,
            .canvas-shell {
                transform: none !important;
            }

            .hud-tag,
            .hud-tag.hud-toggle,
            .guide-btn,
            button,
            input,
            select,
            textarea {
                touch-action: manipulation;
            }
        }

        @media (max-width: 520px) {
            body {
                padding: 24px 12px 42px;
            }

            .input-group {
                justify-content: flex-start;
            }

            .input-group label {
                width: auto;
                min-width: 70px;
                text-align: left;
            }

            #attack3D,
            #attackCanvas {
                width: 100% !important;
                height: auto !important;
                max-width: 100% !important;
                aspect-ratio: 1 / 1;
            }

            .canvas-shell {
                width: 100%;
            }

            #resultContainer {
                overflow-x: auto;
            }
        }
    </style>
</head>
<body class="intro-lock">
    <!-- 视觉层：星空背景 / 指针光晕 / 自定义霓虹提示 / 底部提示条 -->
    <canvas id="starfield"></canvas>
    <div id="cursorGlow"></div>
    <div id="neoTooltip" role="tooltip" aria-hidden="true"></div>
    <div id="neoToast" aria-hidden="true"></div>
    <div id="authOverlay" aria-hidden="false" data-state="idle">
        <canvas id="authGalaxy"></canvas>
        <div class="auth-door" aria-hidden="true">
            <svg viewBox="0 0 1000 1600" preserveAspectRatio="xMidYMid meet" aria-hidden="true">
                <defs>
                    <filter id="authGlow" x="-60%" y="-60%" width="220%" height="220%">
                        <feGaussianBlur stdDeviation="4.2" result="b1" />
                        <feGaussianBlur stdDeviation="1.8" result="b2" />
                        <feMerge>
                            <feMergeNode in="b1" />
                            <feMergeNode in="b2" />
                            <feMergeNode in="SourceGraphic" />
                        </feMerge>
                    </filter>

                    <linearGradient id="authWhite" x1="0" x2="0" y1="0" y2="1">
                        <stop offset="0" stop-color="#FFFFFF" stop-opacity="0.98" />
                        <stop offset="0.55" stop-color="#F6FBFF" stop-opacity="0.92" />
                        <stop offset="1" stop-color="#EAF3FF" stop-opacity="0.96" />
                    </linearGradient>
                </defs>

                <rect x="0" y="0" width="1000" height="1600" fill="rgba(0,0,0,0)" />

                <!-- 门框 + 门缝 -->
                <g filter="url(#authGlow)" opacity="0.42" fill="none">
                    <rect x="90" y="80" width="820" height="1440" rx="28" stroke="rgba(77,210,255,0.18)" stroke-width="8" />
                    <rect x="120" y="110" width="760" height="1380" rx="22" stroke="rgba(168,85,247,0.10)" stroke-width="5" />
                    <path d="M500 120 L500 1480" stroke="rgba(246,251,255,0.24)" stroke-width="6" />
                    <path d="M500 120 L500 1480" stroke="rgba(77,210,255,0.16)" stroke-width="2" />
                </g>

                <!-- 外层蓝辉光（更宽） -->
                <g filter="url(#authGlow)" stroke="rgba(77,210,255,0.32)" stroke-width="14" stroke-linecap="round" stroke-linejoin="round" fill="none" opacity="0.26">
                    <!-- X型主干 -->
                    <path d="M500 800 L160 180" />
                    <path d="M500 800 L840 180" />
                    <path d="M500 800 L160 1420" />
                    <path d="M500 800 L840 1420" />
                    <!-- 左侧电路 -->
                    <path d="M140 160 L320 160 L390 230 L390 520 L320 590 L250 590" />
                    <path d="M250 590 L250 770 L320 840 L390 840" />
                    <path d="M170 1030 L320 1030 L390 1100 L390 1370 L320 1440 L140 1440" />
                    <path d="M250 1030 L250 1210 L320 1280 L390 1280" />
                    <!-- 右侧电路 -->
                    <path d="M860 160 L680 160 L610 230 L610 520 L680 590 L750 590" />
                    <path d="M750 590 L750 770 L680 840 L610 840" />
                    <path d="M860 1030 L680 1030 L610 1100 L610 1370 L680 1440 L860 1440" />
                    <path d="M750 1030 L750 1210 L680 1280 L610 1280" />
                </g>

                <!-- 内层白亮线（更粗更亮） -->
                <g filter="url(#authGlow)" stroke="url(#authWhite)" stroke-width="10" stroke-linecap="round" stroke-linejoin="round" fill="none" opacity="0.86">
                    <!-- X型主干 -->
                    <path d="M500 800 L160 180" />
                    <path d="M500 800 L840 180" />
                    <path d="M500 800 L160 1420" />
                    <path d="M500 800 L840 1420" />

                    <!-- 左侧电路 -->
                    <path d="M140 160 L320 160 L390 230 L390 520 L320 590 L250 590" />
                    <path d="M250 590 L250 770 L320 840 L390 840" />
                    <path d="M190 300 L300 300" />
                    <path d="M190 420 L330 420" />
                    <path d="M170 1030 L320 1030 L390 1100 L390 1370 L320 1440 L140 1440" />
                    <path d="M250 1030 L250 1210 L320 1280 L390 1280" />

                    <!-- 右侧电路 -->
                    <path d="M860 160 L680 160 L610 230 L610 520 L680 590 L750 590" />
                    <path d="M750 590 L750 770 L680 840 L610 840" />
                    <path d="M810 300 L700 300" />
                    <path d="M810 420 L670 420" />
                    <path d="M860 1030 L680 1030 L610 1100 L610 1370 L680 1440 L860 1440" />
                    <path d="M750 1030 L750 1210 L680 1280 L610 1280" />
                </g>

                <!-- 端点斜杠装饰（更像门） -->
                <g filter="url(#authGlow)" stroke="rgba(246,251,255,0.72)" stroke-width="8" stroke-linecap="round" opacity="0.55">
                    <path d="M120 120 L160 150" />
                    <path d="M880 120 L840 150" />
                    <path d="M120 1480 L160 1450" />
                    <path d="M880 1480 L840 1450" />
                    <path d="M180 200 L220 230" />
                    <path d="M820 200 L780 230" />
                    <path d="M180 1400 L220 1370" />
                    <path d="M820 1400 L780 1370" />
                </g>

                <!-- 中心锁芯徽章（更硬核） -->
                <g filter="url(#authGlow)" transform="translate(500 800)" opacity="0.75">
                    <circle r="104" fill="rgba(0,0,0,0.16)" stroke="rgba(246,251,255,0.70)" stroke-width="7" />
                    <circle r="84" fill="none" stroke="rgba(77,210,255,0.46)" stroke-width="5" stroke-dasharray="8 12" />
                    <circle r="12" fill="rgba(82,255,184,0.50)" />
                    <path d="M-58 -10 L-12 -58 L58 -10" stroke="rgba(246,251,255,0.66)" stroke-width="8" fill="none" />
                    <path d="M-52 22 L0 62 L52 22" stroke="rgba(246,251,255,0.66)" stroke-width="8" fill="none" />
                </g>
            </svg>
        </div>
        <canvas id="authFx"></canvas>
        <div class="auth-panel">
            <div class="auth-core"></div>
            <div class="auth-hud">
                <span class="auth-corner tl"></span>
                <span class="auth-corner tr"></span>
                <span class="auth-corner bl"></span>
                <span class="auth-corner br"></span>
            </div>
            <div class="auth-sweep"></div>
            <div class="auth-title">身份验证</div>
            <div class="auth-sub">请确认你的权限以接入战术系统</div>
            <div class="auth-chip"><span>ACCESS LEVEL</span><b>COMMAND</b></div>
            <div class="auth-banner" id="authBanner">等待指令…</div>
            <div class="auth-mini" id="authMini" aria-hidden="true">
                <b id="authMiniPct">0%</b>
                <i id="authMiniBar"></i>
            </div>
            <button type="button" id="authVerifyBtn" class="auth-verify">验证身份</button>
            <div class="auth-welcome" id="authWelcome">
                <div style="font-family: Orbitron, Inter, system-ui, -apple-system, Segoe UI, Arial, sans-serif; font-size: 22px; letter-spacing: 0.18em; color: rgba(236,245,255,0.94);">验证通过</div>
                <div style="font-size: 13px; letter-spacing: 0.10em; color: rgba(236,245,255,0.68);">欢迎你，指挥官</div>
            </div>
        </div>
    </div>

    <div id="introOverlay" aria-hidden="false" data-active="0">
        <canvas id="introFx"></canvas>
        <div class="intro-radar"></div>
        <div class="intro-pulse"></div>
        <div class="intro-card">
            <div class="intro-scan"></div>
            <div class="intro-hud">
                <span class="intro-corner tl"></span>
                <span class="intro-corner tr"></span>
                <span class="intro-corner bl"></span>
                <span class="intro-corner br"></span>
                <div class="intro-metrics">LINK <b id="introLink">OK</b> · SYNC <b id="introSync">98%</b></div>
            </div>
            <div class="intro-granted" id="introGranted">ACCESS GRANTED</div>
            <div class="intro-title" id="introTitle" data-text="空降007">空降007</div>
            <div class="intro-sub" id="introStatus">系统接入中…</div>
            <div class="intro-bar"><i></i></div>
            <div class="intro-log" id="introLog">BOOT: INIT<span class="intro-caret"></span></div>
            <button type="button" id="introSkip">跳过</button>
        </div>
    </div>
    <div class="container">
        <!-- <h1>牛逼同步攻击</h1> -->
        <div class="app-header">
            <div class="app-head-row">
                <div class="app-title" data-text="空降007">空降007</div>
                <div class="app-head-actions">
                    <button type="button" class="guide-btn" id="bgmBtn" data-tip="背景音乐：选择本地音频文件（mp3/wav/flac等）进行播放/暂停">背景音乐</button>
                    <button type="button" class="guide-btn" id="guideBtn" data-tip="打开使用教程（新手建议先看一遍）">使用教程</button>
                </div>
            </div>
            <div class="app-subtitle">高精度落点/出发时间同步计算 · 断曲/末端模式切换 · 中转曲点链路</div>
            <div class="app-meta"><strong>作者</strong> 梅子酒：安文&nbsp;&nbsp;伊甸：桔酱</div>
        </div>
        <div class="hud-section">
            <div class="hud-kicker"><em>01</em> 输入</div>
            <div class="hud-line"></div>
            <button type="button" class="hud-tag hud-toggle" id="toggleInputSection" aria-pressed="false" data-tip="点击收起：坐标输入">坐标</button>
        </div>
        <div class="section-body" id="inputSection" data-collapsed="false">
            <div class="input-group">
                <label id="cutPointLabel" data-tip="固定曲点坐标（随开关变化）。格式示例：(705,1285）">断曲点</label>
                <input type="text" class="border-right-radius-clear" style="padding: 8px; width: 146px; border: 1px solid #ccc;" value="(705,1285)" id="cutPoint" placeholder="(x,y)" data-point="1" data-tip="坐标格式示例：(705,1285）">
                
                <label class="switch" data-tip="开关：勾选=断曲点固定/计算末端中转；取消=末端中转固定/计算断曲点">
                    <input type="checkbox" id="toggleSwitch" checked>
                    <span class="slider"></span>
                </label>
                <script>
                    // 开关切换逻辑
                    document.getElementById('toggleSwitch').addEventListener('change', function() {
                        const checked = this.checked;
                        if (checked) {
                            document.getElementById('cutPointLabel').innerHTML = '断曲点';
                            document.getElementById('transferPointLabel').innerHTML = '末端中转';
                        } else {
                            document.getElementById('cutPointLabel').innerHTML = '末端中转';
                            document.getElementById('transferPointLabel').innerHTML = '断曲点';
                        }
                        calcFixedPoint();
                        inputListener();
                    });
                </script>
            </div>
            <div class="input-group">
                <label data-tip="目标坐标：你希望落地/到达的目标点。格式示例：(1600,1600）">目标坐标</label>
                <input type="text" style="padding: 8px; width: 200px; border: 1px solid #ccc; border-radius: 4px;" value="(1600,1600)" id="targetPoint" placeholder="(x,y)" data-point="1" data-tip="坐标格式示例：(1600,1600）">
            </div>
            <!-- 左右横拉条 -->
            <div class="input-group">
                <label data-tip="距离控制：控制固定曲点到目标延长方向的距离（吉米）。可拖动滑块或直接输入数字。">距离控制</label>
                <input type="range" id="horizontalSlider" min="0" max="3000" step="1" value="2547" style="width: 130px;" data-tip="拖动滑条控制 断曲点/末端中转 的距离约束范围">
                <input type="number" id="horizontalInput" min="0" max="3000" step="1" value="2547" style="width: 92px;" data-tip="手动输入距离（吉米），与滑块同步">
                <span id="horizontalValue" style="width: 52px; opacity: .85;">吉米</span>
            </div>
            <div class="input-group">
                <label id="transferPointLabel" data-tip="另一固定曲点（随开关变化）。该输入框由系统自动计算，无需手动填写。">末端中转</label>
                <input type="text" style="padding: 8px; width: 200px; border: 1px solid #ccc; border-radius: 4px;" value="(3097, 2140)" disabled id="transferPoint" data-tip="末端中转点：由系统根据断曲/目标/距离控制自动计算，无需手动填写">
            </div>
        </div>
        <div class="hud-section">
            <div class="hud-kicker"><em>02</em> 预览</div>
            <div class="hud-line"></div>
            <button type="button" class="hud-tag hud-toggle" id="togglePreviewSection" aria-pressed="false" data-tip="点击收起：航线预览">航线</button>
        </div>
        <div class="section-body" id="previewSection" data-collapsed="false">
            <!-- 画布占位 -->
            <div class="canvas-shell">
                <div class="preview-actions">
                    <button type="button" id="togglePreviewMode" aria-pressed="false" data-tip="切换：二维/三维航线预览">2D</button>
                    <button type="button" id="toggleFlightArrows" aria-pressed="true" data-tip="切换：航线动态箭头显示">箭头开</button>
                    <button type="button" id="fit3DView" data-tip="自动调整视角：完整显示航线" disabled>适配航线</button>
                    <button type="button" id="reset3DView" data-tip="复位三维视角" disabled>复位视角</button>
                </div>
                <canvas id="attackCanvas" width="320" height="320" style="border:1px solid #ccc;margin:20px auto;display:block;"></canvas>
                <canvas id="attackCanvasFx" width="320" height="320" aria-hidden="true"></canvas>
                <div id="attack3D" aria-label="三维交互预览"></div>
            </div>
        </div>
        <div class="input-group">
            <label data-tip="落地时间：用于倒推每队的出发时间。右侧可点击下拉/选择器来选日期与时间。">落地时间</label>
            <input type="datetime-local" id="attackTime" style="padding: 8px; width: 200px; border: 1px solid #ccc; border-radius: 4px;" data-tip="落地时间：用于倒推每队的出发时间。右侧可点击下拉/选择器来选日期与时间。">
        </div>
        <div class="hud-section">
            <div class="hud-kicker"><em>03</em> 路径</div>
            <div class="hud-line"></div>
            <button type="button" class="hud-tag hud-toggle" id="toggleTransferSection" aria-pressed="false" data-tip="点击收起：中转曲点">中转</button>
        </div>
        <div class="section-body" id="transferSection" data-collapsed="false">
            <div id="transferPointsContainer" style="display: none;">
                <label data-tip="中转曲点：航线转向点。格式示例：(3097,2140）">中转曲点</label>
                <input type="text" style="padding: 8px; width: 134px; border: 1px solid #ccc; border-radius: 4px;" value="" placeholder="(x,y)" data-point="1" data-tip="中转曲点坐标：例如 (3097,2140）">
                <button style="height: 33px;font-size: 22px;width: 33px;" onclick="addTransferPoint(this)" data-tip="添加一个新的中转曲点（会插入在当前行下方）">+</button>
                <button style="height: 33px;font-size: 22px;width: 33px;" onclick="removeTransferPoint(this)" data-tip="删除当前中转曲点（至少保留 1 个）">-</button>
            </div>
            <div class="input-group">
                <label data-tip="中转曲点：航线转向点。格式示例：(3097,2140）">中转曲点</label>
                <input type="text" style="padding: 8px; width: 134px; border: 1px solid #ccc; border-radius: 4px;" value="" placeholder="(x,y)" data-point="1" data-tip="中转曲点坐标：例如 (3097,2140）">
                <button style="height: 33px;font-size: 22px;width: 33px;" onclick="addTransferPoint(this)" data-tip="添加一个新的中转曲点（会插入在当前行下方）">+</button>
                <button style="height: 33px;font-size: 22px;width: 33px;" onclick="removeTransferPoint(this)" data-tip="删除当前中转曲点（至少保留 1 个）">-</button>
            </div>
        </div>
        <div class="hud-section">
            <div class="hud-kicker"><em>04</em> 队伍</div>
            <div class="hud-line"></div>
            <button type="button" class="hud-tag hud-toggle" id="toggleTeamSection" aria-pressed="false" data-tip="点击收起：队伍出发点">出发</button>
        </div>
        <div class="section-body" id="teamSection" data-collapsed="false">
            <div id="startPointContainer" style="display: none;">
                <div class="input-group" style="margin-bottom: 5px;">
                    <label data-tip="出发点坐标：例如 (4600,3200）">出发点</label>
                    <input type="text" style="padding: 8px; width: 167px; border: 1px solid #ccc; border-radius: 4px;" value="" placeholder="(x,y)" data-point="1" data-tip="出发点坐标：例如 (4600,3200）">
                    <button style="height: 33px;font-size: 22px;width: 33px;" onclick="addStartPoint(this)" data-tip="添加一个新的出发点组">+</button>
                </div>
                <div class="input-group" style="margin-bottom: 5px;">
                    <label data-tip="队名：用于结果表与三维标签显示（建议简短，例如：安文1队）">队名</label>
                    <input type="text" style="padding: 8px; width: 200px; border: 1px solid #ccc; border-radius: 4px;" value="" data-tip="队名：用于结果表与三维标签显示（建议简短，例如：安文1队）">
                </div>
                <div class="input-group" style="margin-bottom: 5px;">
                    <label data-tip="曲率：该队飞行曲率参数（保持与游戏/你的经验值一致；不确定可先用默认值）">曲率</label>
                    <input type="text" style="padding: 8px; width: 167px; border: 1px solid #ccc; border-radius: 4px;" value="" data-tip="曲率：该队飞行曲率参数（保持与游戏/你的经验值一致；不确定可先用默认值）">
                    <button style="height: 33px;font-size: 22px;width: 33px;" onclick="removeStartPoint(this)" data-tip="删除当前出发点组（至少保留 1 组）">-</button>
                </div>
            </div>
            <div class="start-group">
                <div class="input-group" style="margin-bottom: 5px;">
                    <label data-tip="出发点坐标：例如 (4600,3200）">出发点</label>
                    <input type="text" style="padding: 8px; width: 167px; border: 1px solid #ccc; border-radius: 4px;" value="(4600,3200)" placeholder="(x,y)" data-point="1" data-tip="出发点坐标：例如 (4600,3200）">
                    <button style="height: 33px;font-size: 22px;width: 33px;" onclick="addStartPoint(this)" data-tip="添加一个新的出发点组">+</button>
                </div>
                <div class="input-group" style="margin-bottom: 5px;">
                    <label data-tip="队名：用于结果表与三维标签显示（建议简短，例如：安文1队）">队名</label>
                    <input type="text" style="padding: 8px; width: 200px; border: 1px solid #ccc; border-radius: 4px;" value="安文1队" data-tip="队名：用于结果表与三维标签显示（建议简短，例如：安文1队）">
                </div>
                <div class="input-group" style="margin-bottom: 5px;">
                    <label data-tip="曲率：该队飞行曲率参数（保持与游戏/你的经验值一致；不确定可先用默认值）">曲率</label>
                    <input type="text" style="padding: 8px; width: 167px; border: 1px solid #ccc; border-radius: 4px;" value="4586" data-tip="曲率：该队飞行曲率参数（保持与游戏/你的经验值一致；不确定可先用默认值）">
                    <button style="height: 33px;font-size: 22px;width: 33px;" onclick="removeStartPoint(this)" data-tip="删除当前出发点组（至少保留 1 组）">-</button>
                </div>
            </div>
        </div>
        <!-- 结果显示 -->
        <div class="hud-section">
            <div class="hud-kicker"><em>05</em> 输出</div>
            <div class="hud-line"></div>
            <button type="button" class="hud-tag hud-toggle" id="toggleResultSection" aria-pressed="false" data-tip="点击收起：输出结果">结果</button>
        </div>
        <div class="section-body" id="resultSection" data-collapsed="false">
            <div id="resultContainer" style="margin-top: 20px;text-align: left;">
                <div class="result-actions" id="resultActions" data-show="false">
                    <button type="button" id="copyStartTimeBtn" data-tip="复制：当前高亮队伍的出发时间（点击后可直接粘贴）">时间</button>
                    <button type="button" id="copyOffsetBtn" data-tip="复制：当前高亮队伍的落点偏移（点击后可直接粘贴）">偏移</button>
                    <button type="button" id="copyTargetBtn" data-tip="复制：目标点坐标">目标</button>
                </div>
                <!-- 当前系统时间 -->
                <div>当前时间: <span id="currentTimeText"></span></div>
                <!-- 定时更新 -->
                <script>
                    if (window.intervalValueTemp) clearInterval(window.intervalValueTemp);
                    const __ct = document.getElementById('currentTimeText');
                    if (__ct) {
                        window.intervalValueTemp = setInterval(() => {
                            const now = new Date();
                            const localTime = now.toLocaleString();
                            __ct.textContent = localTime;
                        }, 500); // 每0.5秒钟更新一次
                    }
                </script>
                <div>拆哨时间: <span id="sentryTimeText"></span></div>
                <div>
                    <table style="width: 100%;">
                        <thead>
                            <tr>
                                <th>队名</th>
                                <th>出发</th>
                                <th>落点偏移</th>
                            </tr>
                        </thead>
                        <tbody id="resultBody"></tbody>
                    </table>
                </div>
            </div>
        </div>
        <div class="app-footer" style="display:none"><strong>作者</strong> 梅子酒：安文&nbsp;&nbsp;伊甸：桔酱</div>
    </div>
    <div class="guide-modal" id="guideModal" data-open="false" aria-hidden="true">
        <div class="guide-backdrop" id="guideBackdrop"></div>
        <div class="guide-dialog" role="dialog" aria-modal="true" aria-label="使用教程">
            <div class="guide-head">
                <div class="guide-title">使用教程</div>
                <button type="button" class="guide-close" id="guideClose" data-tip="关闭教程（Esc）">关闭</button>
            </div>
            <ol class="guide-steps">
                <li>在 <strong>输入</strong> 区填写 <strong>断曲点</strong> 与 <strong>目标坐标</strong>（格式：<code>(x,y)</code>）。</li>
                <li>用开关选择模式：<strong>勾选</strong> 表示断曲点固定并计算末端中转；<strong>取消</strong> 表示末端中转固定并计算断曲点。</li>
                <li>拖动 <strong>距离控制</strong> 滑条，调整断曲/末端中转的距离约束范围。</li>
                <li>在 <strong>路径-中转</strong> 区：点击 <strong>+</strong> 添加中转曲点，点击 <strong>-</strong> 删除当前行（至少保留 1 个）。</li>
                <li>在 <strong>队伍-出发</strong> 区：填写每队的出发点/队名/曲率，点击 <strong>+</strong> 添加队伍，点击 <strong>-</strong> 删除队伍。</li>
                <li>在 <strong>预览</strong> 区：默认三维显示，可旋转/缩放；点击 <strong>适配航线</strong> 一键让航线完整显示，点击 <strong>复位视角</strong> 回到默认视角。</li>
                <li>在 <strong>输出</strong> 区：鼠标移到结果行会出现复制按钮，可一键复制 <strong>出发时间</strong> 与 <strong>落点偏移</strong>。</li>
            </ol>
        </div>
    </div>
    <input type="file" id="bgmFile" accept="audio/*" style="display:none">
    <audio id="bgmAudio" preload="none" loop></audio>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script>
        const maxWidth = 9000; //校准宽
        const maxHeight = 9000; //校准高
        const minDistanceRatio = 1.5; //断曲到目标距离与目标到末端曲的最低关系
        const maxDistance = 3000; //最大断曲与末端曲的距离
        const sentryExtent = 5; //前哨外延长度5吉米
        //获取控制元素
        const cutInput = document.getElementById('cutPoint'); //断曲
        const switchInput = document.getElementById('toggleSwitch'); //开关
        const targetInput = document.getElementById('targetPoint'); //目标
        const hSlider = document.getElementById('horizontalSlider');
        const hInput = document.getElementById('horizontalInput');
        const hValue = document.getElementById('horizontalValue');
        const transferInput = document.getElementById('transferPoint'); //末端
        const transferPointsContainer = document.getElementById('transferPointsContainer'); //中转曲点容器
        const startPointsContainer = document.getElementById('startPointContainer'); //出发点容器
        const sentryTimeText = document.getElementById('sentryTimeText'); // 显式获取，避免依赖浏览器把 id 暴露为全局变量
        const attackTimeInput = document.getElementById('attackTime'); //攻击时间
        if (!attackTimeInput.value) {
            // 默认设置为当前时间
            const now = new Date();
            const localDateTime = now.toISOString().slice(0, 16);
            attackTimeInput.value = localDateTime;
        }
        function updateSentryTime() {
            const attackTime = new Date(attackTimeInput.value);
            if (!attackTime || Number.isNaN(attackTime.getTime()) || !sentryTimeText) return;
            attackTime.setMinutes(attackTime.getMinutes() + 30);
            sentryTimeText.textContent = attackTime.toLocaleString().slice(0, 16);
        }
        attackTimeInput.addEventListener('change', updateSentryTime); // 任何情况下都绑定（localStorage回填也要生效）
        // 距离控制：滑块 + 手动输入 双通道，保持同一套计算逻辑
        const syncDistanceUI = (value) => {
            const v = Number.isFinite(Number(value)) ? String(Math.round(Number(value))) : String(hSlider.value);
            hSlider.value = v;
            if (hInput) hInput.value = v;
            if (hValue) hValue.textContent = '吉米';
        };

        hSlider.addEventListener('input', () => {
            syncDistanceUI(hSlider.value);
            calcFixedPoint();
        });

        if (hInput) {
            const applyInput = () => {
                const raw = Number(hInput.value);
                if (!Number.isFinite(raw)) return;
                const minV = Number(hSlider.min || 0);
                const maxV = Number(hSlider.max || 3000);
                const v = Math.max(minV, Math.min(maxV, Math.round(raw)));
                syncDistanceUI(v);
                calcFixedPoint();
            };
            hInput.addEventListener('input', applyInput);
            hInput.addEventListener('change', applyInput);
        }
        // 禁用第一个中转曲点的减按钮
        // document.querySelector('.input-group:nth-child(3) button:nth-child(4)').disabled = true;
        // 生成中转曲点输入行的函数
        function createTransferPoint(data) {
            const group = document.createElement('div');
            group.className = 'input-group';
            group.innerHTML = transferPointsContainer.innerHTML;
            group.querySelectorAll('input').forEach(input => {
                if (data) {
                    input.value = data;
                }
                input.addEventListener('input', inputListener);
            });
            return group;
        }

        // 添加新的中转曲点
        function addTransferPoint(btn, point) {
            const groupEl = btn && btn.closest ? btn.closest('.input-group') : (btn ? btn.parentElement : null);
            const container = (groupEl && groupEl.parentElement) ? groupEl.parentElement : (document.getElementById('transferSection') || document.querySelector('.container'));
            // 兼容：点击“+”时不会传 point；此时复用当前行输入内容（或留空）
            let seed = '';
            if (point && typeof point === 'object' && Number.isFinite(point.x) && Number.isFinite(point.y)) {
                seed = pointToStr(point);
            } else if (typeof point === 'string') {
                seed = point;
            } else {
                try {
                    const inp = groupEl && groupEl.querySelector ? groupEl.querySelector('input') : null;
                    seed = (inp && typeof inp.value === 'string') ? inp.value : '';
                } catch (e) {
                    seed = '';
                }
            }
            const newPoint = createTransferPoint(seed);
            container.insertBefore(newPoint, groupEl ? groupEl.nextElementSibling : null);
            const res = updateTransferPointLabels();
            try { enhanceGroupTips(); } catch (e) {}
            redrawCanvas();
            return res;
        }

        // 删除当前中转曲点
        function removeTransferPoint(btn) {
            const group = btn && btn.closest ? btn.closest('.input-group') : btn.parentElement;
            group.remove();
            updateTransferPointLabels();
            try { enhanceGroupTips(); } catch (e) {}
            redrawCanvas();
        }  
        // 删除当前出发点
        function removeStartPoint(btn) {
            const group = btn && btn.closest ? btn.closest('.start-group') : btn.parentElement.parentElement;
            group.remove();
            updateStartPointLabels();
            try { enhanceGroupTips(); } catch (e) {}
            redrawCanvas();
        }  

        // 让“整行悬停”也能显示提示：给 input-group 自动补齐 data-tip（从行内控件提取）
        function enhanceGroupTips() {
            const groups = document.querySelectorAll('#transferSection .input-group, #teamSection .input-group, #teamSection .start-group');
            groups.forEach(g => {
                if (typeof g.dataset.tip === 'string' && g.dataset.tip.trim()) return;
                const inp = g.querySelector('input[data-tip]');
                if (inp && inp.dataset.tip) {
                    g.dataset.tip = inp.dataset.tip;
                    return;
                }
                const btn = g.querySelector('button[data-tip]');
                if (btn && btn.dataset.tip) {
                    g.dataset.tip = btn.dataset.tip;
                }
            });
        }

        function getTransferPoints() {
            const groups = document.querySelectorAll('.input-group');
            return Array.from(groups).filter(group => group.querySelector('label').textContent.includes('中转曲点'));
        }

        // 更新所有中转曲点标签的序号
        function updateTransferPointLabels() {
            let index = 1;
            const transferPoints = getTransferPoints();
            transferPoints.forEach(group => {
                const label = group.querySelector('label');
                const input = group.querySelector('input');
                label.textContent = `中转曲点${index}`;
                input.id = `transferPoint${index}`;
                index++;
                group.lastElementChild.disabled = transferPoints.length === 1;
            });
        }

        // 生成出发点输入行的函数
        function createStartPoint(data) {
            const group = document.createElement('div');
            group.className = 'start-group';
            group.innerHTML = startPointsContainer.innerHTML;
            group.querySelectorAll('input').forEach((input, index) => {
                if (data) {
                    if (index === 0) {
                        input.value = pointToStr(data.startPoint);
                    } else if (index === 1) {
                        input.value = data.queueName;
                    } else if (index === 2) {
                        input.value = data.curvature;
                    }
                }
                input.addEventListener('input', inputListener);
            });
            return group;
        }
        // 添加新的出发点
        function addStartPoint(btn, data) {
            const groupEl = btn && btn.closest ? btn.closest('.start-group') : (btn ? btn.parentElement.parentElement : null);
            const container = (groupEl && groupEl.parentElement) ? groupEl.parentElement : (document.getElementById('teamSection') || document.querySelector('.container'));
            const newPoint = createStartPoint(data);
            container.insertBefore(newPoint, groupEl ? groupEl.nextElementSibling : null);
            const res = updateStartPointLabels();
            try { enhanceGroupTips(); } catch (e) {}
            redrawCanvas();
            return res;
        }
        function getStartPoints() {
            const groups = document.querySelectorAll('.start-group');
            return Array.from(groups).filter(group => group.querySelector('label').textContent.includes('出发点'));
        }
        // 更新所有出发点标签的序号
        function updateStartPointLabels() {
            let index = 1;
            const startPoints = getStartPoints();
            startPoints.forEach(group => {
                const label = group.querySelector('label');
                const input = group.querySelector('input');
                label.textContent = `出发点${index}`;
                input.id = `startPoint${index}`;
                index++;
                group.lastElementChild.lastElementChild.disabled = startPoints.length === 1;
            });
        }
        // 获取画布与上下文
        const canvas = document.getElementById('attackCanvas');
        const ctx = canvas.getContext('2d');

        // 2D预览交互视图（缩放/平移）
        const view2D = {
            scale: 1,
            tx: 0,
            ty: 0,
            minScale: 0.55,
            maxScale: 4.0
        };

        const ARROW_SPEED_2D = 120;
        const ARROW_SPEED_3D = 90;

        window.flightArrowEnabled = true;

        const reset2DView = () => {
            view2D.scale = 1;
            view2D.tx = 0;
            view2D.ty = 0;
            try { redrawCanvas(); } catch (e) {}
        };

        const fit2DViewToRoute = () => {
            if (!viz2DSegments || !viz2DSegments.length) {
                reset2DView();
                return;
            }
            let minX = Infinity;
            let minY = Infinity;
            let maxX = -Infinity;
            let maxY = -Infinity;
            for (const s of viz2DSegments) {
                if (!s || !s.a || !s.b) continue;
                const pts = [s.a, s.b];
                for (const p of pts) {
                    if (!p || !Number.isFinite(p.x) || !Number.isFinite(p.y)) continue;
                    minX = Math.min(minX, p.x);
                    minY = Math.min(minY, p.y);
                    maxX = Math.max(maxX, p.x);
                    maxY = Math.max(maxY, p.y);
                }
            }
            if (!Number.isFinite(minX) || !Number.isFinite(minY) || !Number.isFinite(maxX) || !Number.isFinite(maxY)) {
                reset2DView();
                return;
            }
            const w = Math.max(1, maxX - minX);
            const h = Math.max(1, maxY - minY);
            const pad = 24;
            const sx = (canvas.width - pad * 2) / w;
            const sy = (canvas.height - pad * 2) / h;
            const s = Math.max(view2D.minScale, Math.min(view2D.maxScale, Math.min(sx, sy)));
            const cx = (minX + maxX) / 2;
            const cy = (minY + maxY) / 2;
            view2D.scale = s;
            view2D.tx = (canvas.width / 2) - cx * s;
            view2D.ty = (canvas.height / 2) - cy * s;
            try { redrawCanvas(); } catch (e) {}
        };

        (function attach2DViewControls() {
            if (!canvas) return;

            const getCanvasPt = (evt) => {
                const r = canvas.getBoundingClientRect();
                const sx = (evt.clientX - r.left) * (canvas.width / Math.max(1, r.width));
                const sy = (evt.clientY - r.top) * (canvas.height / Math.max(1, r.height));
                return { x: sx, y: sy };
            };

            const clamp = (v, a, b) => Math.max(a, Math.min(b, v));

            // 滚轮缩放：以鼠标为中心
            canvas.addEventListener('wheel', (e) => {
                try {
                    const containerEl = document.querySelector('.container');
                    if (containerEl && containerEl.classList.contains('is-3d')) return;
                } catch (err) {}

                e.preventDefault();
                const p = getCanvasPt(e);
                const worldX = (p.x - view2D.tx) / Math.max(1e-6, view2D.scale);
                const worldY = (p.y - view2D.ty) / Math.max(1e-6, view2D.scale);

                const dir = e.deltaY > 0 ? -1 : 1;
                const factor = dir > 0 ? 1.10 : 0.90;
                const nextScale = clamp(view2D.scale * factor, view2D.minScale, view2D.maxScale);

                view2D.scale = nextScale;
                view2D.tx = p.x - worldX * nextScale;
                view2D.ty = p.y - worldY * nextScale;
                redrawCanvas();
            }, { passive: false });

            // 拖拽平移：pointer事件
            let dragging = false;
            let last = { x: 0, y: 0 };

            const onDown = (e) => {
                try {
                    const containerEl = document.querySelector('.container');
                    if (containerEl && containerEl.classList.contains('is-3d')) return;
                } catch (err) {}
                dragging = true;
                canvas.style.cursor = 'grabbing';
                last = getCanvasPt(e);
                try { canvas.setPointerCapture(e.pointerId); } catch (err) {}
            };

            const onMove = (e) => {
                if (!dragging) return;
                const cur = getCanvasPt(e);
                const dx = cur.x - last.x;
                const dy = cur.y - last.y;
                view2D.tx += dx;
                view2D.ty += dy;
                last = cur;
                redrawCanvas();
            };

            const onUp = (e) => {
                if (!dragging) return;
                dragging = false;
                canvas.style.cursor = 'grab';
                try { canvas.releasePointerCapture(e.pointerId); } catch (err) {}
            };

            canvas.addEventListener('pointerdown', onDown);
            window.addEventListener('pointermove', onMove);
            window.addEventListener('pointerup', onUp);
            window.addEventListener('pointercancel', onUp);
            canvas.addEventListener('lostpointercapture', onUp);
        })();
        // 绘制坐标点
        function drawPoint(x, y, label, color = '#ff0000', type = 'circle') {
            ctx.fillStyle = color;
            ctx.beginPath();
            if (type === 'circle') {
                ctx.arc(x, y, 3, 0, 2 * Math.PI);
            } else {
                ctx.rect(x - 5, y - 5, 10, 10);
            }
            ctx.fill();
            
            ctx.fillStyle = color;
            ctx.font = '9px';
            ctx.fillText(label, x + 6, y - 6);
        }

        // 绘制连线
        function drawLine(points) {
            if (points.length < 2) return;
            ctx.strokeStyle = '#007acc';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(points[0].x, points[0].y);
            for (let i = 1; i < points.length; i++) {
                ctx.lineTo(points[i].x, points[i].y);
                // 记录2D线段（用于箭头动画）
                try {
                    const a = points[i - 1];
                    const b = points[i];
                    if (a && b && Number.isFinite(a.x) && Number.isFinite(a.y) && Number.isFinite(b.x) && Number.isFinite(b.y)) {
                        viz2DSegments.push({ a: { x: a.x, y: a.y }, b: { x: b.x, y: b.y } });
                    }
                } catch (e) {}
            }
            ctx.stroke();
        }

        // 2D预览：记录本次绘制的线段（画布坐标），用于动态箭头
        const viz2DSegments = [];

        // 3D预览：记录本次绘制的线段（世界坐标），用于同步到 3D 场景
        const viz3DSegments = [];
        let update3DPreview = null;
        // 注意：如果点带有 fix（前哨角点），需要补同样的偏移，保证 3D 预览与 2D 线段对齐
        function resolveFixedWorldPoint(p) {
            if (!p || !p.fix) return p;
            const offsetX = 5 * maxWidth / canvas.width - 5;
            const offsetY = 5 * maxHeight / canvas.height - 5;
            let xp = 0;
            let yp = 0;
            if (p.fix === 1) {
                xp = -offsetX;
                yp = -offsetY;
            } else if (p.fix === 2) {
                xp = offsetX;
                yp = -offsetY;
            } else if (p.fix === 3) {
                xp = -offsetX;
                yp = offsetY;
            } else if (p.fix === 4) {
                xp = offsetX;
                yp = offsetY;
            }
            return { x: p.x + xp, y: p.y + yp };
        }
        function record3DSegment(p1, p2) {
            if (!p1 || !p2) return;
            const a = resolveFixedWorldPoint(p1);
            const b = resolveFixedWorldPoint(p2);
            viz3DSegments.push({ a: { x: a.x, y: a.y }, b: { x: b.x, y: b.y } });
        }
        function getPoint(input) {
            if (!input || !input.value) return null;
            const [x, y] = input.value.replace(/[()]/g, '').split(',').map(v => parseFloat(v.trim()));
            if (isNaN(x) || isNaN(y)) return null;
            return { x, y };
        }

        /*
        point.fix偏移
        null/0，无偏移
        1，前哨左上
        2，前哨右上
        3，前哨左下
        4，前哨右下
        */
        function getCanvasPoint(point) {
            if (!point) return null;
            let xp = 0;
            let yp = 0;
            const offsetX = 5 * maxWidth / canvas.width - 5;
            const offsetY = 5 * maxHeight / canvas.height - 5;
            if (!point.fix) {
            } else if (point.fix === 1) {
                xp = -offsetX;
                yp = -offsetY;
            } else if (point.fix === 2) {
                xp = offsetX;
                yp = -offsetY;
            } else if (point.fix === 3) {
                xp = -offsetX;
                yp = offsetY;
            } else if (point.fix === 4) {
                xp = offsetX;
                yp = offsetY;
            }
            return { x: (point.x + xp) / maxWidth * canvas.width, y: (maxHeight - point.y + yp) / maxHeight * canvas.height};
        }

        //末端曲点
        function transferPoint() {
            return switchInput.checked ? getPoint(transferInput) : getPoint(cutInput);
        }
        //断曲点
        function cutPoint() {
            return switchInput.checked ? getPoint(cutInput) : getPoint(transferInput);
        }
        // 获取所有中转曲点
        function transferPoints() {
            const transferInputs = getTransferPoints().map(g => g.querySelector('input'));
            return transferInputs.map(inp => getPoint(inp)).filter(p => p !== null);
        }
        // 获取所有出发点
        function startPoints() {
            const startInputs = getStartPoints().map(group => group.querySelector('input'));
            return startInputs.map(inp => getPoint(inp)).filter(p => p !== null);
        }
        // 解析输入坐标并绘制
        function redrawCanvas() {
            // 清屏需在单位矩阵下完成，否则会留下边缘
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // 应用2D视图变换（缩放/平移）
            ctx.setTransform(view2D.scale, 0, 0, view2D.scale, view2D.tx, view2D.ty);
            viz2DSegments.length = 0;
            viz3DSegments.length = 0;
            const targetPoint = getPoint(targetInput);
            const target = getCanvasPoint(targetPoint);
            drawPoint(target.x, target.y, '目标', '#ff0000');
            
            const cutPoint_ = cutPoint();
            const dq = getCanvasPoint(cutPoint_);
            const md = getCanvasPoint(transferPoint());
            drawPoint(dq.x, dq.y, '断曲', '#440000', 'rect');
            drawPoint(md.x, md.y, '末端曲', '#aada66', 'rect');

            // 3D预览：关键参考连线（不影响2D绘制）
            if (targetPoint && cutPoint_) record3DSegment(cutPoint_, targetPoint);
            if (targetPoint && transferPoint()) record3DSegment(targetPoint, transferPoint());

            // const start = getPoint(startInput);
            const transfers = transferPoints().map(inp => getCanvasPoint(inp)).filter(p => p !== null);
            transfers.forEach((p, i) => drawPoint(p.x, p.y, `转${i + 1}`, '#ffda00', 'rect'));
            
            // drawLine([dq, target, md, ...transfers]);
            const lastTransfer = transfers[transfers.length - 1];
            const starts = startPoints().map(inp => getCanvasPoint(inp)).filter(p => p !== null);
            starts.forEach((p, i) => {
                drawPoint(p.x, p.y, `出${i + 1}`, '#00aa00')
            });
            // const usedPoints = startPoints().map(drawStartToCutLine);
            //清理结果
            const resultBody = document.getElementById('resultBody');
            resultBody.innerHTML = '';
            // UI：刷新结果时隐藏复制浮层，避免残留
            const resultActions = document.getElementById('resultActions');
            if (resultActions) {
                resultActions.dataset.show = 'false';
                resultActions.style.transform = 'translate3d(-9999px, -9999px, 0)';
            }
            getStartPointData().map(startTeam => {
                const startPoint = startTeam.startPoint;
                const queueName = startTeam.queueName || startTeam.labelName;
                const curvature = startTeam.curvature;
                const usedPoints = drawStartToCutLine(startPoint);
                if (!startPoint) return {startPoint, usedPoints, curvature, queueName, msg: '未设置出发点'};
                if (!usedPoints.length) return {startPoint, usedPoints, curvature, queueName, msg: '无法连接到目标'};
                if (!curvature) return {startPoint, usedPoints, curvature, queueName, msg: '未设置曲率'};
                //最后一个曲点
                const endPoint = usedPoints[usedPoints.length - 1];
                //最后一个点到目标的垂足
                const distanceToTarget = gcz(targetPoint, endPoint, cutPoint_);
                //偏移量-实际落地点与目标的距离
                const offset = glen(targetPoint, distanceToTarget);
                //总距离
                let totalDistance = 0;
                //最后一个曲点到垂足的距离
                const lastDistance = glen(endPoint, distanceToTarget);
                totalDistance += lastDistance;
                //计算距离
                if (usedPoints.length > 1) {
                    for (let i = 0; i < usedPoints.length - 1; i++) {
                        const s = usedPoints[i];
                        const e = usedPoints[i + 1];
                        totalDistance += glen(s, e);
                    }
                }
                //计算飞行时长
                const duration = gst(totalDistance, curvature);
                //攻击时间
                const attackTimeTime = new Date(attackTimeInput.value);
                //出发时间
                const startTime = new Date(attackTimeTime.getTime() - (duration * 1000));
                return {startPoint, usedPoints, curvature, queueName, offset, duration, startTime};
            }).forEach(showResult)
            
            // const groups = document.querySelectorAll('.start-group');
            // Array.from(groups).map(group => {
            //     const startPoint_group = group.children[0];
            //     const queueName_group = group.children[1];
            //     const curvature_group = group.children[2];
            //     const startPoint = getPoint(startPoint_group.querySelector('input'));
            //     const usedPoints = drawStartToCutLine(startPoint, [], []);
            //     //获取曲率
            //     const curvature = Number(curvature_group.querySelector('input').value);
            //     //获取队名
            //     const queueName = queueName_group.querySelector('input').value || startPoint_group.querySelector('label').textContent;
            //     if (!startPoint) return {startPoint, usedPoints, curvature, queueName, msg: '未设置出发点'};
            //     if (!usedPoints.length) return {startPoint, usedPoints, curvature, queueName, msg: '无法连接到目标'};
            //     if (!curvature) return {startPoint, usedPoints, curvature, queueName, msg: '未设置曲率'};
            //     //最后一个曲点
            //     const endPoint = usedPoints[usedPoints.length - 1];
            //     //最后一个点到目标的垂足
            //     const distanceToTarget = gcz(targetPoint, endPoint, cutPoint_);
            //     //偏移量-实际落地点与目标的距离
            //     const offset = glen(targetPoint, distanceToTarget);
            //     //总距离
            //     let totalDistance = 0;
            //     //最后一个曲点到垂足的距离
            //     const lastDistance = glen(endPoint, distanceToTarget);
            //     totalDistance += lastDistance;
            //     //计算距离
            //     if (usedPoints.length > 1) {
            //         for (let i = 0; i < usedPoints.length - 1; i++) {
            //             const s = usedPoints[i];
            //             const e = usedPoints[i + 1];
            //             totalDistance += glen(s, e);
            //         }
            //     }
            //     //计算飞行时长
            //     const duration = gst(totalDistance, curvature);
            //     //攻击时间
            //     const attackTimeTime = new Date(attackTimeInput.value);
            //     //出发时间
            //     const startTime = new Date(attackTimeTime.getTime() - (duration * 1000));
            //     return {startPoint, usedPoints, curvature, queueName, offset, duration, startTime};
            // }).forEach(showResult)
        }

        // 2D动态箭头（叠加层，不影响原2D绘制）
        (function start2DArrowFx() {
            const fx = document.getElementById('attackCanvasFx');
            if (!fx || !fx.getContext) return;
            const fxc = fx.getContext('2d');
            let raf = 0;

            const syncFxSize = () => {
                try {
                    fx.width = canvas.width;
                    fx.height = canvas.height;
                } catch (e) {}
            };
            syncFxSize();
            try { window.addEventListener('resize', syncFxSize, { passive: true }); } catch (e) { window.addEventListener('resize', syncFxSize); }

            const segLen = (s) => Math.hypot(s.b.x - s.a.x, s.b.y - s.a.y);

            const drawArrow = (x, y, ang, size, alpha) => {
                fxc.save();
                fxc.translate(x, y);
                fxc.rotate(ang);
                fxc.globalAlpha = alpha;

                // 蓝色主箭头
                fxc.fillStyle = 'rgba(77,210,255,0.85)';
                fxc.beginPath();
                fxc.moveTo(size, 0);
                fxc.lineTo(-size * 0.85, size * 0.60);
                fxc.lineTo(-size * 0.85, -size * 0.60);
                fxc.closePath();
                fxc.fill();

                // 白色描边
                fxc.strokeStyle = 'rgba(255,255,255,0.32)';
                fxc.lineWidth = 1.2;
                fxc.stroke();
                fxc.restore();
            };

            const tick = (t) => {
                raf = requestAnimationFrame(tick);

                // 只在2D模式渲染
                try {
                    const ctn = document.querySelector('.container');
                    if (ctn && ctn.classList.contains('is-3d')) {
                        fxc.setTransform(1, 0, 0, 1, 0, 0);
                        fxc.clearRect(0, 0, fx.width, fx.height);
                        return;
                    }
                } catch (e) {}

                if (!window.flightArrowEnabled) {
                    fxc.setTransform(1, 0, 0, 1, 0, 0);
                    fxc.clearRect(0, 0, fx.width, fx.height);
                    return;
                }

                fxc.setTransform(1, 0, 0, 1, 0, 0);
                fxc.clearRect(0, 0, fx.width, fx.height);

                // 跟随2D视图缩放/平移
                fxc.setTransform(view2D.scale, 0, 0, view2D.scale, view2D.tx, view2D.ty);
                if (!viz2DSegments || !viz2DSegments.length) return;

                // 预计算长度
                const segs = viz2DSegments;
                const lens = new Array(segs.length);
                let total = 0;
                for (let i = 0; i < segs.length; i++) {
                    const l = segLen(segs[i]);
                    lens[i] = l;
                    total += l;
                }
                if (total < 1) return;

                const speed = ARROW_SPEED_2D; // px/s
                const base = (t * 0.001 * speed) % total;
                const count = Math.min(10, Math.max(4, Math.floor(total / 110)));

                for (let k = 0; k < count; k++) {
                    let d = (base + (k * total) / count) % total;
                    for (let i = 0; i < segs.length; i++) {
                        const l = lens[i];
                        if (d > l) {
                            d -= l;
                            continue;
                        }
                        const s = segs[i];
                        const ux = (s.b.x - s.a.x) / Math.max(1e-6, l);
                        const uy = (s.b.y - s.a.y) / Math.max(1e-6, l);
                        const x = s.a.x + ux * d;
                        const y = s.a.y + uy * d;
                        const ang = Math.atan2(uy, ux);
                        const size = 6.6;
                        const a = 0.42 + 0.38 * Math.sin((t * 0.001) * 2.0 + k);
                        drawArrow(x, y, ang, size, a);
                        break;
                    }
                }
            };
            raf = requestAnimationFrame(tick);
        })();
        //所有出发点资料
        function getStartPointData() {
            const groups = document.querySelectorAll('.start-group');
            const startPoints = [];
            groups.forEach(group => {
                const startPoint_group = group.children[0];
                const queueName_group = group.children[1];
                const curvature_group = group.children[2];
                const startPoint = getPoint(startPoint_group.querySelector('input'));
                const curvature = Number(curvature_group.querySelector('input').value);
                const queueName = queueName_group.querySelector('input').value;
                const labelName = startPoint_group.querySelector('label').textContent;
                startPoints.push({startPoint, curvature, queueName, labelName});
            });
            return startPoints;
        }
        // 显示结果
        function showResult(item) {
            const resultBody = document.getElementById('resultBody');
            const tr = document.createElement('tr');
            resultBody.appendChild(tr);
            if (item.msg) {
                tr.style.color = 'red';
                // 修复：不要在 <tr> 里再嵌套 <tr>
                tr.dataset.copyable = '0';
                tr.innerHTML = `<td class="res-queueName">${item.queueName}</td><td colspan="2">${item.msg}</td>`;
            } else {
                tr.dataset.copyable = '1';
                tr.dataset.startTime = item.startTime.toLocaleTimeString();
                tr.dataset.offset = item.offset.toFixed(1);
                tr.innerHTML = `<td class="res-queueName">${item.queueName}</td><td>${item.startTime.toLocaleTimeString()}</td><td>${item.offset.toFixed(1)}</td>`;
                // div.textContent = `${item.queueName} ${item.startTime.toLocaleString()}`;
            }
        }
        //计算飞行时长(秒)
        function gst(len, v) { return Math.round((len / v) * 10000) / 10000 };
        //绘制出发点到断曲的线,返回所有经过的点(不包含断曲点),如果无法画线,返回空数组
        function drawStartToCutLine(startPoint, used, res) {
            if (!used || !used.findIndex) used = [];
            if (!startPoint) return [];
            if (!res) res = [startPoint];
            const transferPoint_ = transferPoint();
            const cutPoint_ = cutPoint();
            const distance = glen(startPoint, cutPoint_);
            const sentryPosition = getSentryPosition(cutPoint_) //断曲哨的位置
            const sentryCorners = qu(sentryPosition); //断曲哨的4个角
            const endSentryPosition = getSentryPosition(transferPoint_) //末端哨的位置
            const endSentryCorners = qu(endSentryPosition); //末端哨的4个角
            if (distance < maxDistance) {
                // 出发点到断曲小于3000吉米
                const endPoint = short(startPoint, ...sentryCorners);
                record3DSegment(startPoint, endPoint);
                drawLine([getCanvasPoint(startPoint), getCanvasPoint(endPoint)]);
                return res;
            }
            // 出发点到末端曲小于3000吉米
            if (glen(startPoint, transferPoint_) < maxDistance) {
                const endPoint = short(startPoint, ...endSentryCorners);
                record3DSegment(startPoint, endPoint);
                drawLine([getCanvasPoint(startPoint), getCanvasPoint(endPoint)]);
                return drawStartToCutLine(endPoint, [...used, transferPoint_], [...res, endPoint]);
            }
            //在中转曲点里面找小于3000吉米，并且最远的点
            const transferPoints_ = transferPoints();
            let transferPointsWithDistance = transferPoints_
            .map(p => {return {p, distance: glen(startPoint, p)}})
            .filter(p => used.findIndex(u => u.x === p.p.x && u.y === p.p.y) == -1)
            .filter(p => p.distance < maxDistance)
            .sort((a, b) => b.distance - a.distance);
            if (transferPointsWithDistance.length === 0) {
                //没有合适的中转曲点,说明都超过3000吉米，无法画线
                return [];
            }
            if (transferPointsWithDistance.length > 1) {
                //有多个中转曲点，找到距离断曲最近的中转曲点
                transferPointsWithDistance = transferPointsWithDistance
                .map(p => {return {...p, distance_cut: glen(sentryPosition, p.p)}})
                .sort((a, b) => a.distance_cut - b.distance_cut);
            }
            //找到最远的中转曲点
            const transferPoint_next = transferPointsWithDistance[0].p;
            const sentryPosition_next = getSentryPosition(transferPoint_next) //中转哨的位置
            const sentryCorners_next = qu(sentryPosition_next); //中转哨的4个角
            const midPoint = short(startPoint, ...sentryCorners_next);
            record3DSegment(startPoint, midPoint);
            drawLine([getCanvasPoint(startPoint), getCanvasPoint(midPoint)]);
            return drawStartToCutLine(midPoint, [...used, transferPoint_next], [...res, midPoint]);
        }

        // 输入事件处理函数
        function inputListener() {
            //重新计算
            //重新画图
            redrawCanvas();
            //保存数据
            saveData();
        }

        // 绑定输入事件
        document.querySelectorAll('input').forEach(input => {
            input.addEventListener('input', inputListener);
        });

        function pointToStr(point) {
            if (!point) return '';
            const x = Number(point.x);
            const y = Number(point.y);
            if (!Number.isFinite(x) || !Number.isFinite(y)) return '';
            return `(${x.toFixed(0)},${y.toFixed(0)})`;
        }
        // 两点距离
        function glen(p1, p2) { return Math.round(Math.sqrt(Math.pow(Math.abs(p1.x - p2.x), 2) + Math.pow(Math.abs(p1.y - p2.y), 2)) * 100) /100 }

        //距离控制的上限和下限
        function updateDistanceRange() {
            let value = Number(hSlider.value);
            const distance = writeDistance();
            if (!distance) return;
            let relMinValue = 0;
            let relMaxValue = Math.floor(maxDistance - (sentryExtent * Math.sqrt(2)));
            if (switchInput.checked) {
                if (distance > 1200) {
                    transferInput.value = `距离不能大于1200吉米`;
                    return;
                }
                relMinValue = Math.ceil(distance * minDistanceRatio + distance);
            } else {
                relMinValue = Math.ceil(distance + 5);
                const maxDistanceRatio = Math.ceil(distance / minDistanceRatio);
                relMaxValue = Math.ceil(Math.min(maxDistanceRatio, 1200) + distance);
            }
            if (value < relMinValue) {
                // 修复：Math.random() 无参数，这里需要把滑条值拉回合法区间
                hSlider.value = Math.floor(relMinValue + Math.random() * Math.max(1, (relMaxValue - relMinValue)));
                value = Number(hSlider.value);
            }
            if (value > relMaxValue) {
                hSlider.value = relMaxValue;
                value = Number(hSlider.value);
            }
            hSlider.attributes.min.value = relMinValue;
            hSlider.attributes.max.value = relMaxValue;
            if (hInput) {
                hInput.min = String(relMinValue);
                hInput.max = String(relMaxValue);
            }
            syncDistanceUI(hSlider.value);
            calcFixedPoint();
            inputListener();
        }
        
        //写入值与目标的距离
        function writeDistance() {
            const target = getPoint(targetInput);
            const cut = getPoint(cutInput);
            if (!target || !cut) {
                return;
            }
            return glen(target, cut);
        }

        //根据开关选择,和距离控制计算固定曲点(断曲/末端)
        function calcFixedPoint() {
            const isFixed = switchInput.checked; //开关
            const target = getPoint(targetInput);
            const cut = getPoint(cutInput);
            const hSliderValue = hSlider.value;
            if (!target || !cut) {
                transferInput.value = `先输入目标和${isFixed?'断曲点':'末端曲点'}`;
                return;
            }
            const distance = writeDistance();
            if (!distance) return;
            if (switchInput.checked && distance > 1200) {
                transferInput.value = `距离不能大于1200吉米`;
                return;
            }
            let fixedPoint = cut;
            if (switchInput.checked) {
                fixedPoint = short(target, ...qu(cut));
            } else {
                fixedPoint = looner(target, ...qu(cut));
            }
            // 根据写入坐标连接目标延长线，延长距离后的点
            const angle = Math.atan2(target.y - fixedPoint.y, target.x - fixedPoint.x);
            const newX = fixedPoint.x + Math.cos(angle) * hSliderValue;
            const newY = fixedPoint.y + Math.sin(angle) * hSliderValue;
            transferInput.value = pointToStr(getSentryPosition({ x: newX, y: newY }));
        }

        //根据坐标获取前哨的位置
        function getSentryPosition(point) {
            let xt = point.x / 10
            let yt = point.y / 10
            let x = Math.ceil(xt) * 10 + 5
            let y = Math.ceil(yt) * 10 + 5
            return {x, y}
        }
        
        // 垂足计算
        function gcz(point, start, end) {
          var A = end.x - start.x;
          var B = start.y - end.y;
          var C = end.y * start.x - start.y * end.x;
          if (A*A+B*B<1e-13) {
            return start // 起点与终点重合
          } else if (Math.abs(A * point.y + B * point.x + C) < 1e-13) {
            return point // 点在线段(起点,终点)上
          } else {
            var y = (B* B* point.y - A * B * point.x - A* C)/(A * A+ B * B)
            var x =(-A* B* point.y + A * A * point.x - B* C)/(A * A + B * B)
            return { y: Math.round(y * 100) / 100, x: Math.round(x * 100) / 100 }
          }
        }
        
        //前哨4个角的坐标
        // 1，前哨左上
        // 2，前哨右上
        // 3，前哨左下
        // 4，前哨右下
        function qu(point) {
          let xt = point.x / 10
          let yt = point.y / 10
          let x1 = Math.ceil(xt) * 10
          let x2 = Math.floor(xt) * 10
          let y1 = Math.ceil(yt) * 10
          let y2 = Math.floor(yt) * 10
          return [{ x: x1, y: y1, fix: 2 }, { x: x1, y: y2, fix: 4 }, { x: x2, y: y1, fix: 1 }, { x: x2, y: y2, fix: 3 }];
        }
        // 最短距离点
        function short(p1, ...pr) {
          return pr.map(p => {return { e: p, l: glen(p1, p)}}).sort((a, b) => a.l - b.l)[0].e
        }
        // 最长距离点
        function looner(p1, ...pr) {
          return pr.map(p => {return { e: p, l: glen(p1, p)}}).sort((a, b) => b.l - a.l)[0].e
        }
        
        //绑定事件
        cutInput.addEventListener('input', () => {
            updateDistanceRange();
        })
        targetInput.addEventListener('input', () => {
            updateDistanceRange();
        })
        switchInput.addEventListener('change', () => {
            updateDistanceRange();
        })
        //将所有input的数据整理成对象
        function getInputData() {
            return {
                //目标
                target: targetInput.value,
                //断曲点/末端曲点
                cut: cutInput.value,
                //距离
                hSlider: hSlider.value,
                //模式切换
                switch: switchInput.checked,
                //落地时间
                attackTime: attackTimeInput.value,
                //所有中转曲点
                transferPoints: transferPoints(),
                //所有出发点
                startPoints: getStartPointData()
            }
        }
        function saveData() {
            localStorage.setItem('kongjiang007', JSON.stringify(getInputData()));
        }
        function getLocalData() {
            return JSON.parse(localStorage.getItem('kongjiang007'));
        }
        // 填充中转曲点
        function intoTransferPoints(transferPointsData) {
            if (!transferPointsData) return;
            // 获取当前中转曲点的数量
            const currentCount = getTransferPoints();
            let transfer_local;
            // 遍历所有中转曲点数据
            transferPointsData.forEach((point, index) => {
                // 如果当前中转曲点数量小于数据数量，添加新的中转曲点
                if (index >= currentCount.length) {
                    transfer_local = addTransferPoint(transfer_local.querySelector('button'), point);
                    return;
                }
                // 填充当前中转曲点数据
                transfer_local =currentCount[index]
                transfer_local.querySelector('input').value = pointToStr(point);
            });
        }
        // 填充出发点
        function intoStartPointsData(startPointsData) {
            if (!startPointsData) return;
            //获取当前出发点的数量
            const currentStartCount = getStartPoints();
            let start_local;
            // 遍历所有出发点数据
            startPointsData.forEach((point, index) => {
                // 如果当前出发点数量小于数据数量，添加新的出发点
                if (index >= currentStartCount.length) {
                    start_local = addStartPoint(start_local.children[0].querySelector('button'), point);
                    return;
                }
                // 填充当前出发点数据
                start_local =currentStartCount[index]
                const startPoint_group = start_local.children[0];
                startPoint_group.querySelector('input').value = pointToStr(point.startPoint);
                const queueName_group = start_local.children[1];
                queueName_group.querySelector('input').value = point.queueName;
                const curvature_group = start_local.children[2];
                curvature_group.querySelector('input').value = point.curvature;
            });
        }
        // 初始化页面
        function initPage() {
            // 从本地存储中获取数据
            const localData = getLocalData();
            if (localData) {
                // 填充输入框
                targetInput.value = localData.target;
                cutInput.value = localData.cut;
                hSlider.value = localData.hSlider;
                switchInput.checked = localData.switch;
                attackTimeInput.value = localData.attackTime;
                // 填充中转曲点
                intoTransferPoints(localData.transferPoints);
                // 填充出发点
                intoStartPointsData(localData.startPoints);
            }
            updateSentryTime();
            // 初始化时更新一次序号
            updateTransferPointLabels();
            updateStartPointLabels();
            updateDistanceRange();
            // 初始绘制
            redrawCanvas();
            try { enhanceGroupTips(); } catch (e) {}
        }
        initPage();

        (() => {
            const prefersReduce = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches;
            const hoverNone = window.matchMedia && window.matchMedia('(hover: none)').matches;
            const anyHover = window.matchMedia && window.matchMedia('(any-hover: hover)').matches;
            const finePointer = window.matchMedia && window.matchMedia('(pointer: fine)').matches;
            const canHover = Boolean(anyHover || finePointer || !hoverNone);

            const tooltipEl = document.getElementById('neoTooltip');
            const toastEl = document.getElementById('neoToast');
            const cursorGlow = document.getElementById('cursorGlow');
            const containerEl = document.querySelector('.container');
            const starCanvas = document.getElementById('starfield');

            const authOverlay = document.getElementById('authOverlay');
            const authVerifyBtn = document.getElementById('authVerifyBtn');
            const authBanner = document.getElementById('authBanner');
            const authMini = document.getElementById('authMini');
            const authMiniBar = document.getElementById('authMiniBar');
            const authMiniPct = document.getElementById('authMiniPct');
            const authFx = document.getElementById('authFx');
            const authGalaxy = document.getElementById('authGalaxy');

            const introOverlay = document.getElementById('introOverlay');
            const introSkip = document.getElementById('introSkip');
            const introTitle = document.getElementById('introTitle');
            const introStatus = document.getElementById('introStatus');
            const introLink = document.getElementById('introLink');
            const introSync = document.getElementById('introSync');
            const introGranted = document.getElementById('introGranted');
            const introLog = document.getElementById('introLog');
            const introFx = document.getElementById('introFx');
            const introProgress = introOverlay ? introOverlay.querySelector('.intro-bar > i') : null;
            let introRemoved = false;
            let introTimer = 0;
            let introGlitchTimer = 0;
            let introRaf = 0;
            let introLogTimer = 0;
            let introFxCleanup = null;
            let introStarted = false;
            const removeIntro = () => {
                if (introRemoved) return;
                introRemoved = true;
                if (introTimer) clearInterval(introTimer);
                introTimer = 0;
                if (introGlitchTimer) clearInterval(introGlitchTimer);
                introGlitchTimer = 0;
                if (introLogTimer) clearInterval(introLogTimer);
                introLogTimer = 0;
                if (introRaf) cancelAnimationFrame(introRaf);
                introRaf = 0;
                if (typeof introFxCleanup === 'function') {
                    try { introFxCleanup(); } catch (e) {}
                }
                introFxCleanup = null;
                try { document.body.classList.remove('intro-lock'); } catch (e) {}
                if (introOverlay && introOverlay.parentNode) introOverlay.parentNode.removeChild(introOverlay);
            };
            const startIntroOut = () => {
                if (!introOverlay || introRemoved) return;
                if (introOverlay.dataset.out === '1') return;
                introOverlay.dataset.out = '1';
                setTimeout(removeIntro, 520);
            };
            const startIntro = () => {
                if (!introOverlay || introRemoved || introStarted) return;
                introStarted = true;
                introOverlay.dataset.active = '1';

                let introK = 0;
                let grantedShown = false;
                let hashLogged = false;
                let exploded = false;

                if (!prefersReduce) {
                    const INTRO_DURATION = 2600;
                    const INTRO_TICK = 50;
                    const phases = [
                        { p: 0, t: '系统接入中…' },
                        { p: 14, t: '建立链路 / 探测网络…' },
                        { p: 28, t: '加载航线模块…' },
                        { p: 42, t: '校验坐标格式…' },
                        { p: 58, t: '同步队伍参数…' },
                        { p: 78, t: '建立三维预览…' },
                        { p: 92, t: '接口就绪…' }
                    ];
                    let phaseIdx = 0;
                    const clamp01 = (v) => Math.max(0, Math.min(1, v));
                    const t0 = performance && performance.now ? performance.now() : Date.now();
                    introTimer = setInterval(() => {
                        const now = performance && performance.now ? performance.now() : Date.now();
                        const k = clamp01((now - t0) / INTRO_DURATION);
                        introK = k;
                        const p = Math.round(k * 100);
                        if (introProgress) introProgress.style.width = `${p}%`;
                        if (introSync) introSync.textContent = `${p}%`;

                        while (phaseIdx + 1 < phases.length && p >= phases[phaseIdx + 1].p) phaseIdx++;
                        if (introStatus) introStatus.textContent = phases[phaseIdx].t;

                        if (introLink) {
                            const risk = (p < 20) ? 0.12 : (p < 50 ? 0.05 : 0.02);
                            introLink.textContent = (Math.random() < risk) ? 'CHK' : 'OK';
                        }

                        // A：末段校验/解密 + ACCESS GRANTED
                        if (p >= 88 && !grantedShown) {
                            grantedShown = true;
                            if (introGranted) {
                                introGranted.dataset.show = '1';
                                setTimeout(() => {
                                    try { delete introGranted.dataset.show; } catch (e) { introGranted.dataset.show = '0'; }
                                }, 700);
                            }
                        }
                        if (p >= 92 && introLog && !hashLogged) {
                            hashLogged = true;
                            const hex = Math.random().toString(16).slice(2, 10).toUpperCase();
                            const msg = `SEC: VERIFY-SIGN  0x${hex}  OK`;
                            const lines = (introLog.textContent || '').split('\n').filter(Boolean).slice(-5);
                            lines.push(msg);
                            introLog.innerHTML = `${lines.join('<br>')}<span class="intro-caret"></span>`;
                        }

                        if (p >= 100) {
                            clearInterval(introTimer);
                            introTimer = 0;
                            if (introLink) introLink.textContent = 'OK';
                            if (introStatus) introStatus.textContent = '接口就绪…';
                            setTimeout(startIntroOut, 320);
                        }
                    }, INTRO_TICK);

                    if (introLog) {
                        const logLines = [
                            'BOOT: INIT',
                            'NET: LINK-UP',
                            'AUTH: OK',
                            'IO: CALIBRATE',
                            'MAP: LOAD',
                            '3D: WARMUP',
                            'SYNC: HANDSHAKE',
                            'READY: OK'
                        ];
                        let head = 0;
                        const buf = [];
                        introLogTimer = setInterval(() => {
                            const tag = logLines[head % logLines.length];
                            head++;
                            const hex = Math.random().toString(16).slice(2, 10).toUpperCase();
                            const t = new Date();
                            const ts = `${String(t.getMinutes()).padStart(2, '0')}:${String(t.getSeconds()).padStart(2, '0')}.${String(Math.floor(t.getMilliseconds() / 10)).padStart(2, '0')}`;
                            const msg = `${ts}  ${tag}  0x${hex}`;
                            buf.push(msg);
                            while (buf.length > 6) buf.shift();
                            introLog.innerHTML = `${buf.join('<br>')}<span class="intro-caret"></span>`;
                        }, 150);
                    }

                    if (introFx && introFx.getContext) {
                        const ctx = introFx.getContext('2d');
                        const dpr = Math.min(2, window.devicePixelRatio || 1);
                        const particles = [];
                        const maxP = 64;
                        const rnd = (a, b) => a + Math.random() * (b - a);
                        let removedResize = false;
                        const resize = () => {
                            const w = Math.max(1, introOverlay.clientWidth);
                            const h = Math.max(1, introOverlay.clientHeight);
                            introFx.width = Math.floor(w * dpr);
                            introFx.height = Math.floor(h * dpr);
                            introFx.style.width = `${w}px`;
                            introFx.style.height = `${h}px`;
                            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
                        };
                        resize();
                        try {
                            window.addEventListener('resize', resize, { passive: true });
                        } catch (e) {
                            window.addEventListener('resize', resize);
                        }
                        introFxCleanup = () => {
                            if (removedResize) return;
                            removedResize = true;
                            try { window.removeEventListener('resize', resize); } catch (e) {}
                        };

                        for (let i = 0; i < maxP; i++) {
                            particles.push({
                                x: rnd(0, introOverlay.clientWidth),
                                y: rnd(0, introOverlay.clientHeight),
                                vx: rnd(-0.22, 0.22),
                                vy: rnd(-0.18, 0.18),
                                r: rnd(0.8, 2.2),
                                a: rnd(0.25, 0.85),
                                c: (Math.random() > 0.55) ? '77,210,255' : '168,85,247'
                            });
                        }

                        const draw = () => {
                            if (introRemoved || !introOverlay || !document.body.contains(introOverlay)) return;
                            const w = introOverlay.clientWidth;
                            const h = introOverlay.clientHeight;
                            ctx.clearRect(0, 0, w, h);
                            ctx.globalCompositeOperation = 'lighter';

                            const cx = w * 0.5;
                            const cy = h * 0.5;
                            // B：最后20%聚合，100%爆发
                            if (!exploded && introK >= 0.80) {
                                const strength = Math.min(1, (introK - 0.80) / 0.20);
                                for (const p of particles) {
                                    const dx = cx - p.x;
                                    const dy = cy - p.y;
                                    p.vx += (dx / Math.max(1, Math.hypot(dx, dy))) * (0.018 * strength);
                                    p.vy += (dy / Math.max(1, Math.hypot(dx, dy))) * (0.018 * strength);
                                    p.vx *= 0.985;
                                    p.vy *= 0.985;
                                }
                            }
                            if (!exploded && introK >= 0.995) {
                                exploded = true;
                                for (const p of particles) {
                                    const ang = Math.random() * Math.PI * 2;
                                    const sp = 1.6 + Math.random() * 2.6;
                                    p.vx = Math.cos(ang) * sp;
                                    p.vy = Math.sin(ang) * sp;
                                    p.a = Math.min(0.95, p.a + 0.25);
                                }
                            }

                            for (const p of particles) {
                                p.x += p.vx;
                                p.y += p.vy;
                                if (p.x < -10) p.x = w + 10;
                                if (p.x > w + 10) p.x = -10;
                                if (p.y < -10) p.y = h + 10;
                                if (p.y > h + 10) p.y = -10;

                                ctx.beginPath();
                                ctx.fillStyle = `rgba(${p.c}, ${p.a})`;
                                ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
                                ctx.fill();
                            }

                            for (let i = 0; i < particles.length; i++) {
                                const a = particles[i];
                                for (let j = i + 1; j < particles.length; j++) {
                                    const b = particles[j];
                                    const dx = a.x - b.x;
                                    const dy = a.y - b.y;
                                    const d2 = dx * dx + dy * dy;
                                    const maxD = 120;
                                    if (d2 > maxD * maxD) continue;
                                    const t = 1 - Math.sqrt(d2) / maxD;
                                    ctx.strokeStyle = `rgba(77,210,255, ${0.10 * t})`;
                                    ctx.lineWidth = 1;
                                    ctx.beginPath();
                                    ctx.moveTo(a.x, a.y);
                                    ctx.lineTo(b.x, b.y);
                                    ctx.stroke();
                                }
                            }

                            ctx.globalCompositeOperation = 'source-over';
                            introRaf = requestAnimationFrame(draw);
                        };
                        introRaf = requestAnimationFrame(draw);
                    }

                    if (introTitle) {
                        let flick = 0;
                        introGlitchTimer = setInterval(() => {
                            flick++;
                            const on = (flick % 6 === 0) || (Math.random() > 0.86);
                            if (on) introTitle.setAttribute('data-glitch', '1');
                            else introTitle.removeAttribute('data-glitch');
                        }, 90);
                    }
                }

                if (introSkip) {
                    introSkip.addEventListener('click', (e) => {
                        try { e.preventDefault(); e.stopPropagation(); } catch (err) {}
                        startIntroOut();
                    });
                }

                if (prefersReduce) {
                    setTimeout(removeIntro, 0);
                } else {
                    introOverlay.addEventListener('animationend', (e) => {
                        if (!e || e.animationName !== 'introOut') return;
                        removeIntro();
                    });
                }
            };

            let authRaf = 0;
            let authTimer = 0;
            let authFxCleanup = null;
            let authGalaxyRaf = 0;
            let authGalaxyCleanup = null;
            const removeAuth = () => {
                if (authTimer) clearInterval(authTimer);
                authTimer = 0;
                if (authRaf) cancelAnimationFrame(authRaf);
                authRaf = 0;
                if (typeof authFxCleanup === 'function') {
                    try { authFxCleanup(); } catch (e) {}
                }
                authFxCleanup = null;
                if (authGalaxyRaf) cancelAnimationFrame(authGalaxyRaf);
                authGalaxyRaf = 0;
                if (typeof authGalaxyCleanup === 'function') {
                    try { authGalaxyCleanup(); } catch (e) {}
                }
                authGalaxyCleanup = null;
                if (!authOverlay || !authOverlay.parentNode) return;
                authOverlay.parentNode.removeChild(authOverlay);
            };

            const startAuthGalaxy = () => {
                if (prefersReduce) return;
                if (!authOverlay || !authGalaxy || !authGalaxy.getContext) return;
                const ctx = authGalaxy.getContext('2d');
                const dpr = Math.min(2, window.devicePixelRatio || 1);
                let removedResize = false;

                const resize = () => {
                    const w = Math.max(1, authOverlay.clientWidth);
                    const h = Math.max(1, authOverlay.clientHeight);
                    authGalaxy.width = Math.floor(w * dpr);
                    authGalaxy.height = Math.floor(h * dpr);
                    authGalaxy.style.width = `${w}px`;
                    authGalaxy.style.height = `${h}px`;
                    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
                };
                resize();
                try {
                    window.addEventListener('resize', resize, { passive: true });
                } catch (e) {
                    window.addEventListener('resize', resize);
                }
                authGalaxyCleanup = () => {
                    if (removedResize) return;
                    removedResize = true;
                    try { window.removeEventListener('resize', resize); } catch (e) {}
                };

                const rnd = (a, b) => a + Math.random() * (b - a);

                // 多层星点（视差）：近/中/远
                const layers = [
                    { n: 70, z: 0.45, a0: 0.22 },
                    { n: 120, z: 0.70, a0: 0.16 },
                    { n: 170, z: 1.0, a0: 0.12 }
                ];
                const stars = [];
                const w0 = Math.max(1, authOverlay.clientWidth);
                const h0 = Math.max(1, authOverlay.clientHeight);
                for (const L of layers) {
                    for (let i = 0; i < L.n; i++) {
                        const warm = Math.random() > 0.72;
                        stars.push({
                            x: rnd(0, w0),
                            y: rnd(0, h0),
                            z: L.z,
                            a0: L.a0,
                            tw: rnd(0.8, 3.8),
                            sz: rnd(0.5, 1.8) * (1.05 - L.z * 0.35),
                            c: warm ? '255,232,210' : ((Math.random() > 0.55) ? '77,210,255' : '168,85,247')
                        });
                    }
                }

                // 尘埃/雾化颗粒
                const dust = [];
                const dustN = 220;
                for (let i = 0; i < dustN; i++) {
                    dust.push({
                        x: rnd(0, w0),
                        y: rnd(0, h0),
                        z: rnd(0.55, 1.1),
                        a0: rnd(0.03, 0.12),
                        sz: rnd(0.8, 2.3),
                        c: (Math.random() > 0.5) ? '77,210,255' : '168,85,247'
                    });
                }

                // 银河悬臂：对数螺旋分布点（摄影感：亮点+尘埃沿臂分布）
                const armDust = [];
                const armCount = 3;
                const armPts = 620;
                for (let i = 0; i < armPts; i++) {
                    const arm = i % armCount;
                    const t = Math.random();
                    const warm = Math.random() > 0.80;
                    armDust.push({
                        arm,
                        t,
                        jitterA: rnd(-0.14, 0.14),
                        jitterR: rnd(-18, 18),
                        a0: rnd(0.030, 0.085),
                        sz: rnd(0.6, 1.8) * (0.9 + 0.4 * (1 - t)),
                        c: warm ? '255,232,210' : ((Math.random() > 0.55) ? '77,210,255' : '168,85,247')
                    });
                }

                let t0 = performance && performance.now ? performance.now() : Date.now();
                const draw = () => {
                    if (!authOverlay || !document.body.contains(authOverlay)) return;
                    const w = authOverlay.clientWidth;
                    const h = authOverlay.clientHeight;
                    const cx = w * 0.5;
                    const cy = h * 0.5;

                    const now = performance && performance.now ? performance.now() : Date.now();
                    const tt = (now - t0) * 0.001;

                    ctx.clearRect(0, 0, w, h);

                    // 背景暗场 + 星云云雾（摄影感）
                    const base = ctx.createRadialGradient(cx, cy, 0, cx, cy, Math.max(w, h) * 0.78);
                    base.addColorStop(0, 'rgba(14,20,44,0.60)');
                    base.addColorStop(0.42, 'rgba(8,12,28,0.34)');
                    base.addColorStop(1, 'rgba(0,0,0,0.18)');
                    ctx.fillStyle = base;
                    ctx.fillRect(0, 0, w, h);

                    const corePulse = 0.55 + 0.45 * Math.sin(tt * 0.55);
                    ctx.globalCompositeOperation = 'lighter';
                    const neb1 = ctx.createRadialGradient(cx, cy, 0, cx, cy, Math.max(w, h) * 0.68);
                    neb1.addColorStop(0, `rgba(255,255,255,${0.022 + 0.014 * corePulse})`);
                    neb1.addColorStop(0.16, `rgba(77,210,255,${0.10 + 0.05 * corePulse})`);
                    neb1.addColorStop(0.46, `rgba(168,85,247,${0.085 + 0.03 * corePulse})`);
                    neb1.addColorStop(0.72, `rgba(82,255,184,${0.028})`);
                    neb1.addColorStop(1, 'rgba(0,0,0,0)');
                    ctx.fillStyle = neb1;
                    ctx.beginPath();
                    ctx.arc(cx, cy, Math.max(w, h) * 0.68, 0, Math.PI * 2);
                    ctx.fill();

                    // 第二层更厚的云雾（偏紫）
                    const neb2 = ctx.createRadialGradient(cx, cy, Math.max(w, h) * 0.08, cx, cy, Math.max(w, h) * 0.75);
                    neb2.addColorStop(0, `rgba(168,85,247,${0.05 + 0.03 * corePulse})`);
                    neb2.addColorStop(0.35, `rgba(77,210,255,${0.04 + 0.02 * corePulse})`);
                    neb2.addColorStop(0.75, 'rgba(255,232,210,0.010)');
                    neb2.addColorStop(1, 'rgba(0,0,0,0)');
                    ctx.fillStyle = neb2;
                    ctx.beginPath();
                    ctx.arc(cx, cy, Math.max(w, h) * 0.75, 0, Math.PI * 2);
                    ctx.fill();

                    // 尘埃带（斜向云雾）
                    const band = ctx.createLinearGradient(0, h * 0.15, w, h * 0.85);
                    band.addColorStop(0, 'rgba(77,210,255,0)');
                    band.addColorStop(0.30, 'rgba(77,210,255,0.055)');
                    band.addColorStop(0.55, 'rgba(168,85,247,0.055)');
                    band.addColorStop(0.78, 'rgba(255,232,210,0.032)');
                    band.addColorStop(1, 'rgba(255,232,210,0)');
                    ctx.fillStyle = band;
                    ctx.fillRect(0, 0, w, h);

                    // 银河悬臂：对数螺旋（轻旋转）
                    const maxR = Math.min(w, h) * 0.46;
                    const rot = tt * 0.05;
                    const twist = 5.2;
                    for (const p of armDust) {
                        const baseA = (p.arm * (Math.PI * 2 / armCount));
                        const rr0 = Math.pow(p.t, 0.62) * maxR;
                        const rr = rr0 + p.jitterR;
                        const aa = baseA + (p.t * twist) + rot + p.jitterA * (0.55 + 0.45 * (1 - p.t));
                        const x = cx + Math.cos(aa) * rr;
                        const y = cy + Math.sin(aa) * rr;
                        if (x < -40 || x > w + 40 || y < -40 || y > h + 40) continue;
                        const a = p.a0 * (0.85 + 0.35 * corePulse);

                        // 先画柔光晕
                        ctx.fillStyle = `rgba(${p.c}, ${a * 0.62})`;
                        ctx.beginPath();
                        ctx.arc(x, y, p.sz * 4.2, 0, Math.PI * 2);
                        ctx.fill();

                        // 再画星点
                        ctx.fillStyle = `rgba(${p.c}, ${a})`;
                        ctx.beginPath();
                        ctx.arc(x, y, p.sz, 0, Math.PI * 2);
                        ctx.fill();
                    }

                    // 尘埃颗粒（轻漂移视差）
                    for (const d of dust) {
                        const dx = (tt * 14) * (1 - d.z);
                        const dy = (tt * 9) * (1 - d.z);
                        const x = (d.x + dx) % (w + 40) - 20;
                        const y = (d.y + dy) % (h + 40) - 20;
                        ctx.fillStyle = `rgba(${d.c}, ${d.a0})`;
                        ctx.beginPath();
                        ctx.arc(x, y, d.sz, 0, Math.PI * 2);
                        ctx.fill();
                    }

                    // 星点：多层视差漂移 + 闪烁
                    for (const s of stars) {
                        const driftX = tt * 10 * (1 - s.z);
                        const driftY = tt * 7 * (1 - s.z);
                        const x = (s.x + driftX) % (w + 60) - 30;
                        const y = (s.y + driftY) % (h + 60) - 30;
                        const tw = 0.65 + 0.35 * Math.sin(tt * s.tw + s.x * 0.01);
                        const a = s.a0 + 0.16 * tw;
                        ctx.fillStyle = `rgba(${s.c}, ${a})`;
                        ctx.beginPath();
                        ctx.arc(x, y, s.sz, 0, Math.PI * 2);
                        ctx.fill();

                        // 少量大星做柔光晕
                        if (s.sz > 1.35 && Math.random() > 0.96) {
                            ctx.fillStyle = `rgba(${s.c}, ${0.06 * tw})`;
                            ctx.beginPath();
                            ctx.arc(x, y, s.sz * 4.5, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }

                    // 中心亮核（呼吸）
                    const core = ctx.createRadialGradient(cx, cy, 0, cx, cy, Math.min(w, h) * 0.14);
                    core.addColorStop(0, `rgba(255,255,255,${0.10 + 0.06 * corePulse})`);
                    core.addColorStop(0.4, `rgba(77,210,255,${0.08 + 0.05 * corePulse})`);
                    core.addColorStop(1, 'rgba(0,0,0,0)');
                    ctx.fillStyle = core;
                    ctx.beginPath();
                    ctx.arc(cx, cy, Math.min(w, h) * 0.14, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.globalCompositeOperation = 'source-over';
                    authGalaxyRaf = requestAnimationFrame(draw);
                };
                authGalaxyRaf = requestAnimationFrame(draw);
            };

            const startAuthFx = () => {
                if (!authOverlay || !authFx || !authFx.getContext) return;
                const ctx = authFx.getContext('2d');
                const dpr = Math.min(2, window.devicePixelRatio || 1);
                const nodes = [];
                const maxN = 46;
                const rnd = (a, b) => a + Math.random() * (b - a);
                let removedResize = false;

                const resize = () => {
                    const w = Math.max(1, authOverlay.clientWidth);
                    const h = Math.max(1, authOverlay.clientHeight);
                    authFx.width = Math.floor(w * dpr);
                    authFx.height = Math.floor(h * dpr);
                    authFx.style.width = `${w}px`;
                    authFx.style.height = `${h}px`;
                    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
                };
                resize();
                try {
                    window.addEventListener('resize', resize, { passive: true });
                } catch (e) {
                    window.addEventListener('resize', resize);
                }
                authFxCleanup = () => {
                    if (removedResize) return;
                    removedResize = true;
                    try { window.removeEventListener('resize', resize); } catch (e) {}
                };

                const w0 = authOverlay.clientWidth;
                const h0 = authOverlay.clientHeight;
                for (let i = 0; i < maxN; i++) {
                    nodes.push({
                        x: rnd(0, w0),
                        y: rnd(0, h0),
                        vx: rnd(-0.18, 0.18),
                        vy: rnd(-0.14, 0.14),
                        r: rnd(0.8, 2.0),
                        a: rnd(0.20, 0.62),
                        c: (Math.random() > 0.62) ? '77,210,255' : '168,85,247'
                    });
                }

                const draw = () => {
                    if (!authOverlay || !document.body.contains(authOverlay)) return;
                    const w = authOverlay.clientWidth;
                    const h = authOverlay.clientHeight;
                    ctx.clearRect(0, 0, w, h);
                    ctx.globalCompositeOperation = 'lighter';

                    for (const n of nodes) {
                        n.x += n.vx;
                        n.y += n.vy;
                        if (n.x < -10) n.x = w + 10;
                        if (n.x > w + 10) n.x = -10;
                        if (n.y < -10) n.y = h + 10;
                        if (n.y > h + 10) n.y = -10;
                        ctx.beginPath();
                        ctx.fillStyle = `rgba(${n.c}, ${n.a})`;
                        ctx.arc(n.x, n.y, n.r, 0, Math.PI * 2);
                        ctx.fill();
                    }

                    for (let i = 0; i < nodes.length; i++) {
                        const a = nodes[i];
                        for (let j = i + 1; j < nodes.length; j++) {
                            const b = nodes[j];
                            const dx = a.x - b.x;
                            const dy = a.y - b.y;
                            const d2 = dx * dx + dy * dy;
                            const maxD = 160;
                            if (d2 > maxD * maxD) continue;
                            const t = 1 - Math.sqrt(d2) / maxD;
                            ctx.strokeStyle = `rgba(77,210,255, ${0.10 * t})`;
                            ctx.lineWidth = 1;
                            ctx.beginPath();
                            ctx.moveTo(a.x, a.y);
                            ctx.lineTo(b.x, b.y);
                            ctx.stroke();
                        }
                    }
                    ctx.globalCompositeOperation = 'source-over';
                    authRaf = requestAnimationFrame(draw);
                };
                authRaf = requestAnimationFrame(draw);
            };

            if (authOverlay) {
                startAuthGalaxy();
                startAuthFx();
                // 阻止直接进入启动界面：必须点击验证
                if (authVerifyBtn) {
                    authVerifyBtn.addEventListener('click', () => {
                        if (authVerifyBtn.disabled) return;
                        authVerifyBtn.disabled = true;
                        if (authBanner) authBanner.textContent = '正在验证身份…';

                        if (authMini) {
                            authMini.setAttribute('aria-hidden', 'false');
                        }

                        if (authMiniBar) authMiniBar.style.width = '0%';
                        if (authMiniPct) authMiniPct.textContent = '0%';

                        let pct = 0;
                        const tick = () => {
                            pct += 4 + Math.floor(Math.random() * 6);
                            if (pct > 100) pct = 100;
                            if (authMiniBar) authMiniBar.style.width = `${pct}%`;
                            if (authMiniPct) authMiniPct.textContent = `${pct}%`;
                            if (pct >= 100) {
                                if (authTimer) clearInterval(authTimer);
                                authTimer = 0;
                                if (authBanner) authBanner.textContent = '校验签名 / 授权通过…';
                                setTimeout(() => {
                                    try { authOverlay.dataset.state = 'ok'; } catch (e) {}
                                    if (authBanner) authBanner.innerHTML = '<strong>ACCESS GRANTED</strong> · 欢迎你，指挥官';
                                }, 240);

                                setTimeout(() => {
                                    try { authOverlay.dataset.out = '1'; } catch (e) {}
                                    setTimeout(() => {
                                        startIntro();
                                        removeAuth();
                                    }, 520);
                                }, 980);
                            }
                        };
                        authTimer = setInterval(tick, 90);
                        tick();
                    });
                }

                if (prefersReduce) {
                    // reduced-motion：直接跳过验证与启动遮罩
                    setTimeout(() => {
                        removeAuth();
                        if (introOverlay) {
                            introOverlay.dataset.active = '1';
                            removeIntro();
                        } else {
                            try { document.body.classList.remove('intro-lock'); } catch (e) {}
                        }
                    }, 0);
                }
            } else {
                // 兼容：如果验证遮罩不存在，则直接进入启动界面
                startIntro();
            }

            const guideBtn = document.getElementById('guideBtn');
            const guideModal = document.getElementById('guideModal');
            const guideBackdrop = document.getElementById('guideBackdrop');
            const guideClose = document.getElementById('guideClose');

            const bgmBtn = document.getElementById('bgmBtn');
            const bgmFile = document.getElementById('bgmFile');
            const bgmAudio = document.getElementById('bgmAudio');

            const toggleTransferBtn = document.getElementById('toggleTransferSection');
            const toggleTeamBtn = document.getElementById('toggleTeamSection');
            const transferSection = document.getElementById('transferSection');
            const teamSection = document.getElementById('teamSection');

            const toggleInputBtn = document.getElementById('toggleInputSection');
            const togglePreviewBtn = document.getElementById('togglePreviewSection');
            const toggleResultBtn = document.getElementById('toggleResultSection');
            const inputSection = document.getElementById('inputSection');
            const previewSection = document.getElementById('previewSection');
            const resultSection = document.getElementById('resultSection');

            // 3D交互预览：不改变你原本的绘图/计算逻辑，只把结果“可视化”为可旋转视角
            const togglePreviewModeBtn = document.getElementById('togglePreviewMode');
            const toggleFlightArrowsBtn = document.getElementById('toggleFlightArrows');
            const fit3DBtn = document.getElementById('fit3DView');
            const reset3DBtn = document.getElementById('reset3DView');
            const attack3DEl = document.getElementById('attack3D');
            const attack2DCanvas = document.getElementById('attackCanvas');
            let threeState = null;
            let threeRaf = 0;

            const is3DActive = () => containerEl && containerEl.classList.contains('is-3d');

            const stop3D = () => {
                if (threeRaf) cancelAnimationFrame(threeRaf);
                threeRaf = 0;
            };

            const syncPreviewModeUI = () => {
                const is3D = is3DActive();
                if (togglePreviewModeBtn) {
                    togglePreviewModeBtn.setAttribute('aria-pressed', is3D ? 'true' : 'false');
                    // 文案显示“当前模式”，避免歧义
                    togglePreviewModeBtn.textContent = is3D ? '3D' : '2D';
                }

                if (toggleFlightArrowsBtn) {
                    const on = Boolean(window.flightArrowEnabled);
                    toggleFlightArrowsBtn.setAttribute('aria-pressed', on ? 'true' : 'false');
                    toggleFlightArrowsBtn.textContent = on ? '箭头开' : '箭头关';
                }

                // 2D模式下也允许“适配/复位”（控制的是2D视图）；3D模式下仍需three初始化
                const allowControls = is3D ? Boolean(threeState) : true;
                if (fit3DBtn) fit3DBtn.disabled = !allowControls;
                if (reset3DBtn) reset3DBtn.disabled = !allowControls;
            };

            const start3D = () => {
                if (!threeState || threeRaf) return;
                const loop = () => {
                    if (!threeState || !is3DActive()) {
                        stop3D();
                        return;
                    }
                    try {
                        if (threeState._arrowFn) threeState._arrowFn();
                    } catch (e) {}
                    threeState.controls.update();
                    try { updateLabelScales(); } catch (e) {}
                    threeState.renderer.render(threeState.scene, threeState.camera);
                    threeRaf = requestAnimationFrame(loop);
                };
                threeRaf = requestAnimationFrame(loop);
            };

            const tmpV3 = window.THREE ? new THREE.Vector3() : null;
            const updateLabelScales = () => {
                if (!threeState || !window.THREE) return;
                const cam = threeState.camera;
                const ren = threeState.renderer;
                const root = threeState.root;

                const elH = (ren.domElement && ren.domElement.clientHeight) ? ren.domElement.clientHeight : (attack3DEl ? attack3DEl.clientHeight : 320);
                const fov = (cam.fov * Math.PI) / 180;

                root.traverse((obj) => {
                    if (!obj || !obj.isSprite || !obj.userData || !obj.userData._isLabel) return;
                    const u = obj.userData;
                    const pos = (tmpV3 ? obj.getWorldPosition(tmpV3) : obj.position);
                    const dist = cam.position.distanceTo(pos);
                    const worldH = 2 * Math.tan(fov / 2) * dist;
                    const worldPerPx = worldH / Math.max(1, elH);
                    const hWorld = worldPerPx * (u.desiredH || 26);
                    const wWorld = hWorld * (u.pxW / Math.max(1, u.pxH));
                    obj.scale.set(wWorld, hWorld, 1);
                });
            };

            const fitCameraToRadius = (radius) => {
                if (!threeState || !window.THREE) return;
                const cam = threeState.camera;
                const controls = threeState.controls;

                const vFov = (cam.fov * Math.PI) / 180;
                const hFov = 2 * Math.atan(Math.tan(vFov / 2) * cam.aspect);
                const fitFov = Math.min(vFov, hFov);
                const dist = (radius * 1.25) / Math.tan(fitFov / 2);

                const dir = cam.position.clone().sub(controls.target).normalize();
                cam.position.copy(dir.multiplyScalar(dist).add(controls.target));
                cam.near = Math.max(0.1, dist / 500);
                cam.far = Math.max(5000, dist * 10);
                cam.updateProjectionMatrix();

                controls.minDistance = Math.max(40, dist * 0.25);
                controls.maxDistance = Math.max(800, dist * 4);
                controls.update();
            };

            const init3D = () => {
                if (!attack3DEl) return null;
                if (!window.THREE || !THREE.WebGLRenderer) return null;
                if (threeState) return threeState;
                if (!THREE.OrbitControls) return null;

                const w = attack3DEl.clientWidth || 320;
                const h = attack3DEl.clientHeight || 320;

                const scene = new THREE.Scene();
                scene.fog = new THREE.Fog(0x05070d, 120, 1100);

                const camera = new THREE.PerspectiveCamera(45, w / h, 0.1, 5000);
                camera.position.set(220, 260, 260);

                const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                renderer.setPixelRatio(window.devicePixelRatio || 1);
                renderer.setSize(w, h);
                renderer.setClearColor(0x000000, 0);
                attack3DEl.innerHTML = '';
                attack3DEl.appendChild(renderer.domElement);

                const controls = new THREE.OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.dampingFactor = 0.08;
                controls.enablePan = true;
                controls.minDistance = 60;
                controls.maxDistance = 1600;

                scene.add(new THREE.AmbientLight(0xffffff, 0.55));
                const key = new THREE.DirectionalLight(0x4dd2ff, 0.85);
                key.position.set(1, 2, 1);
                scene.add(key);

                const grid = new THREE.GridHelper(800, 20, 0x2bdcff, 0x123244);
                grid.material.opacity = 0.18;
                grid.material.transparent = true;
                scene.add(grid);

                const root = new THREE.Group();
                scene.add(root);

                const resize = () => {
                    if (!threeState) return;
                    const nw = attack3DEl.clientWidth || 320;
                    const nh = attack3DEl.clientHeight || 320;
                    threeState.camera.aspect = nw / nh;
                    threeState.camera.updateProjectionMatrix();
                    threeState.renderer.setSize(nw, nh);
                    if (is3DActive()) start3D();
                };
                window.addEventListener('resize', resize);

                threeState = { scene, camera, renderer, controls, root, resize };
                syncPreviewModeUI();
                return threeState;
            };

            const makeLabelSprite = (text, color) => {
                if (!window.THREE) return null;
                const canvas = document.createElement('canvas');
                const c = canvas.getContext('2d');
                if (!c) return null;

                const fontSize = 22;
                const padX = 14;
                const padY = 10;
                c.font = `600 ${fontSize}px Orbitron, Inter, Arial, sans-serif`;
                const w = Math.ceil(c.measureText(text).width + padX * 2);
                const h = Math.ceil(fontSize + padY * 2);
                const dpr = Math.min(2, window.devicePixelRatio || 1);
                canvas.width = Math.ceil(w * dpr);
                canvas.height = Math.ceil(h * dpr);
                c.setTransform(dpr, 0, 0, dpr, 0, 0);

                c.font = `600 ${fontSize}px Orbitron, Inter, Arial, sans-serif`;
                c.textBaseline = 'middle';

                // 背板 + 霓虹描边
                c.fillStyle = 'rgba(5, 7, 13, 0.55)';
                c.strokeStyle = 'rgba(77,210,255,0.25)';
                c.lineWidth = 2;
                c.beginPath();
                const r = 10;
                c.moveTo(r, 1);
                c.arcTo(w - 1, 1, w - 1, h - 1, r);
                c.arcTo(w - 1, h - 1, 1, h - 1, r);
                c.arcTo(1, h - 1, 1, 1, r);
                c.arcTo(1, 1, w - 1, 1, r);
                c.closePath();
                c.fill();
                c.stroke();

                const hex = `#${(color >>> 0).toString(16).padStart(6, '0')}`;
                c.shadowColor = hex;
                c.shadowBlur = 14;
                c.fillStyle = hex;
                c.fillText(text, padX, h / 2);

                const tex = new THREE.CanvasTexture(canvas);
                tex.minFilter = THREE.LinearFilter;
                tex.magFilter = THREE.LinearFilter;
                const mat = new THREE.SpriteMaterial({
                    map: tex,
                    transparent: true,
                    depthTest: false,
                    depthWrite: false
                });
                const sp = new THREE.Sprite(mat);

                // 给恒定像素缩放用的数据：w/h 是 CSS 像素尺寸（非 dpr 后的 canvas 像素）
                sp.userData._isLabel = true;
                sp.userData.pxW = w;
                sp.userData.pxH = h;
                sp.userData.desiredH = 28;
                return sp;
            };

            const update3D = () => {
                if (!is3DActive()) return;
                const st = init3D();
                if (!st) {
                    // 3D依赖未加载/或WebGL不可用时，给用户一个提示
                    showToast('三维预览不可用：已自动切回二维（请检查联网或更换浏览器）');
                    containerEl.classList.remove('is-3d');
                    if (fit3DBtn) fit3DBtn.disabled = true;
                    if (reset3DBtn) reset3DBtn.disabled = true;
                    return;
                }

                // 清空旧几何
                while (st.root.children.length) {
                    const child = st.root.children[0];
                    st.root.remove(child);
                    try {
                        if (child.material) {
                            if (child.material.map) child.material.map.dispose();
                            child.material.dispose();
                        }
                        if (child.geometry) child.geometry.dispose();
                    } catch (e) {}
                }

                // 收集点集，用于居中与缩放
                const pts = [];
                const addPt = (p) => { if (p && Number.isFinite(p.x) && Number.isFinite(p.y)) pts.push(p); };
                addPt(getPoint(document.getElementById('targetPoint')));
                addPt(cutPoint());
                addPt(transferPoint());
                transferPoints().forEach(addPt);
                startPoints().forEach(addPt);
                viz3DSegments.forEach(s => { addPt(s.a); addPt(s.b); });

                const center = pts.length ? pts.reduce((acc, p) => ({ x: acc.x + p.x, y: acc.y + p.y }), { x: 0, y: 0 }) : { x: 0, y: 0 };
                if (pts.length) { center.x /= pts.length; center.y /= pts.length; }

                let maxR = 1;
                pts.forEach(p => {
                    const dx = p.x - center.x;
                    const dy = p.y - center.y;
                    maxR = Math.max(maxR, Math.sqrt(dx*dx + dy*dy));
                });

                const scale = 260 / Math.max(300, maxR);
                const map = (p, h = 0) => new THREE.Vector3((p.x - center.x) * scale, h, (p.y - center.y) * scale);
                const labelOffset = 12;

                // 关键点
                const mats = {
                    target: new THREE.MeshBasicMaterial({ color: 0xff3355 }),
                    cut: new THREE.MeshBasicMaterial({ color: 0x662222 }),
                    end: new THREE.MeshBasicMaterial({ color: 0x7cff7a }),
                    transfer: new THREE.MeshBasicMaterial({ color: 0xffda00 }),
                    start: new THREE.MeshBasicMaterial({ color: 0x00ff88 })
                };
                const mkSphere = (mat, r = 3.6) => new THREE.Mesh(new THREE.SphereGeometry(r, 16, 12), mat);

                const tp = getPoint(document.getElementById('targetPoint'));
                const cp = cutPoint();
                const ep = transferPoint();
                if (tp) {
                    const m = mkSphere(mats.target, 4.4);
                    m.position.copy(map(tp, 2));
                    st.root.add(m);
                    const lab = makeLabelSprite('目标', 0xff3355);
                    if (lab) { lab.position.copy(map(tp, 2 + labelOffset)); st.root.add(lab); }
                }
                if (cp) {
                    const m = mkSphere(mats.cut, 4.0);
                    m.position.copy(map(cp, 3));
                    st.root.add(m);
                    const lab = makeLabelSprite('断曲', 0x662222);
                    if (lab) { lab.position.copy(map(cp, 3 + labelOffset)); st.root.add(lab); }
                }
                if (ep) {
                    const m = mkSphere(mats.end, 4.0);
                    m.position.copy(map(ep, 3));
                    st.root.add(m);
                    const lab = makeLabelSprite('末端曲', 0x7cff7a);
                    if (lab) { lab.position.copy(map(ep, 3 + labelOffset)); st.root.add(lab); }
                }

                transferPoints().forEach((p, i) => {
                    const m = mkSphere(mats.transfer, 3.2);
                    m.position.copy(map(p, 2.2));
                    st.root.add(m);
                    const lab = makeLabelSprite(`转${i + 1}`, 0xffda00);
                    if (lab) { lab.position.copy(map(p, 2.2 + labelOffset)); st.root.add(lab); }
                });

                const startGroups = (typeof getStartPoints === 'function') ? getStartPoints() : [];
                startPoints().forEach((p, i) => {
                    const m = mkSphere(mats.start, 3.2);
                    m.position.copy(map(p, 2.2));
                    st.root.add(m);

                    let name = `出${i + 1}`;
                    try {
                        const g = startGroups[i];
                        if (g) {
                            const ins = g.querySelectorAll('input');
                            const q = (ins && ins[1] && ins[1].value) ? ins[1].value.trim() : '';
                            if (q) name += `·${q.length > 10 ? (q.slice(0, 10) + '…') : q}`;
                        }
                    } catch (e) {}
                    const lab = makeLabelSprite(name, 0x00ff88);
                    if (lab) { lab.position.copy(map(p, 2.2 + labelOffset)); st.root.add(lab); }
                });

                // 路径线段（来自2D逻辑的真实分段）
                const segMat = new THREE.LineBasicMaterial({ color: 0x4dd2ff, transparent: true, opacity: 0.75 });
                viz3DSegments.forEach(s => {
                    const g = new THREE.BufferGeometry().setFromPoints([map(s.a, 1.2), map(s.b, 1.2)]);
                    st.root.add(new THREE.Line(g, segMat));
                });

                // 3D动态箭头：沿真实线段移动
                const arrowGroup = new THREE.Group();
                st.root.add(arrowGroup);
                arrowGroup.visible = Boolean(window.flightArrowEnabled);

                const path = [];
                viz3DSegments.forEach(s => {
                    const a = map(s.a, 1.2);
                    const b = map(s.b, 1.2);
                    const l = a.distanceTo(b);
                    if (l > 1e-6) path.push({ a, b, l, dir: b.clone().sub(a).normalize() });
                });

                const arrowCount = Math.min(10, Math.max(4, Math.floor(path.reduce((acc, p) => acc + p.l, 0) / 90)));
                const coneGeo = new THREE.ConeGeometry(3.0, 10.0, 10);
                const coneMat = new THREE.MeshBasicMaterial({ color: 0x4dd2ff, transparent: true, opacity: 0.85, depthWrite: false });
                const cones = [];
                for (let i = 0; i < arrowCount; i++) {
                    const m = new THREE.Mesh(coneGeo, coneMat);
                    m.renderOrder = 5;
                    arrowGroup.add(m);
                    cones.push(m);
                }

                const totalLen = path.reduce((acc, p) => acc + p.l, 0);
                const q = new THREE.Quaternion();
                const up = new THREE.Vector3(0, 1, 0);
                const updateArrows = () => {
                    if (!is3DActive() || !threeState || threeState !== st) return;
                    if (!totalLen || !path.length) return;
                    arrowGroup.visible = Boolean(window.flightArrowEnabled);
                    if (!arrowGroup.visible) return;
                    const t = (performance && performance.now ? performance.now() : Date.now()) * 0.001;
                    const speed = ARROW_SPEED_3D; // world units/s
                    const base = (t * speed) % totalLen;

                    for (let k = 0; k < cones.length; k++) {
                        let d = (base + (k * totalLen) / cones.length) % totalLen;
                        for (let i = 0; i < path.length; i++) {
                            const seg = path[i];
                            if (d > seg.l) {
                                d -= seg.l;
                                continue;
                            }
                            const pos = seg.a.clone().add(seg.dir.clone().multiplyScalar(d));
                            cones[k].position.copy(pos);

                            // Cone默认朝+y，旋转到方向
                            q.setFromUnitVectors(up, seg.dir);
                            cones[k].quaternion.copy(q);
                            break;
                        }
                    }
                };

                st._arrowFn = updateArrows;
                updateArrows();

                // 视角中心
                st.controls.target.set(0, 0, 0);
                st.controls.update();
                updateLabelScales();
                st._lastFitRadius = Math.max(120, (maxR * scale) + 40);
                if (!st._autoFitted) {
                    st._autoFitted = true;
                    fitCameraToRadius(st._lastFitRadius);
                }
                st.renderer.render(st.scene, st.camera);
                start3D();
            };

            if (reset3DBtn) {
                reset3DBtn.addEventListener('click', () => {
                    if (!is3DActive()) {
                        reset2DView();
                        showToast('已复位二维视角');
                        return;
                    }
                    if (!threeState) return;
                    threeState.camera.position.set(220, 260, 260);
                    threeState.controls.target.set(0, 0, 0);
                    threeState.controls.update();
                    showToast('已复位三维视角');
                });
            }

            if (fit3DBtn) {
                fit3DBtn.addEventListener('click', () => {
                    if (!is3DActive()) {
                        fit2DViewToRoute();
                        showToast('已适配二维航线');
                        return;
                    }
                    if (!threeState || !threeState._lastFitRadius) return;
                    threeState.controls.target.set(0, 0, 0);
                    fitCameraToRadius(threeState._lastFitRadius);
                    updateLabelScales();
                    showToast('已适配航线视角');
                });
            }

            // 让业务绘制结束后可以触发 3D 同步
            update3DPreview = update3D;

            // 默认3D：页面首次加载后主动渲染一次（若失败会自动回退到2D）
            if (is3DActive()) {
                if (document.fonts && document.fonts.ready) {
                    document.fonts.ready.then(() => requestAnimationFrame(update3D));
                } else {
                    requestAnimationFrame(update3D);
                }
            }

            // 2D/3D 切换按钮
            if (togglePreviewModeBtn && containerEl) {
                togglePreviewModeBtn.addEventListener('click', () => {
                    const next3D = !is3DActive();
                    if (next3D) {
                        containerEl.classList.add('is-3d');
                        const st = init3D();
                        if (!st) {
                            // init3D 内部会处理提示与回退，这里同步一下UI
                            containerEl.classList.remove('is-3d');
                            syncPreviewModeUI();
                            return;
                        }
                        if (document.fonts && document.fonts.ready) {
                            document.fonts.ready.then(() => requestAnimationFrame(update3D));
                        } else {
                            requestAnimationFrame(update3D);
                        }
                    } else {
                        containerEl.classList.remove('is-3d');
                        stop3D();
                        // 防止3D画面残留输入焦点/滚轮事件影响：切回2D时把焦点给canvas（如存在）
                        try { if (attack2DCanvas && attack2DCanvas.focus) attack2DCanvas.focus(); } catch (e) {}
                        try { if (typeof redrawCanvas === 'function') redrawCanvas(); } catch (e) {}
                    }
                    syncPreviewModeUI();
                });
            }

            if (toggleFlightArrowsBtn) {
                toggleFlightArrowsBtn.addEventListener('click', () => {
                    window.flightArrowEnabled = !window.flightArrowEnabled;
                    // 立即刷新一次（关掉时清屏/隐藏）
                    try { if (typeof redrawCanvas === 'function') redrawCanvas(); } catch (e) {}
                    syncPreviewModeUI();
                });
            }

            syncPreviewModeUI();

            // 视觉增强：底部提示与复制（不影响原计算/绘图逻辑）
            function showToast(text) {
                if (!toastEl) return;
                toastEl.textContent = text;
                toastEl.dataset.show = 'true';
                toastEl.setAttribute('aria-hidden', 'false');
                window.clearTimeout(showToast._t);
                showToast._t = window.setTimeout(() => {
                    toastEl.dataset.show = 'false';
                    toastEl.setAttribute('aria-hidden', 'true');
                }, 1200);
            }

            async function copyText(text) {
                try {
                    if (navigator.clipboard && window.isSecureContext) {
                        await navigator.clipboard.writeText(text);
                        return true;
                    }
                } catch (e) {}

                // 降级：非安全上下文/权限失败时，尝试 execCommand 复制
                try {
                    const ta = document.createElement('textarea');
                    ta.value = text;
                    ta.setAttribute('readonly', '');
                    ta.style.position = 'fixed';
                    ta.style.left = '-9999px';
                    ta.style.top = '-9999px';
                    document.body.appendChild(ta);
                    ta.select();
                    const ok = document.execCommand('copy');
                    ta.remove();
                    return ok;
                } catch (e) {
                    return false;
                }
            }

            // B：坐标输入格式校验（仅视觉提示，不拦截原逻辑）
            const pointRegex = /^\s*\(?\s*-?\d+(?:\.\d+)?\s*,\s*-?\d+(?:\.\d+)?\s*\)?\s*$/;
            const validatePointInput = (el) => {
                if (!el || el.tagName !== 'INPUT') return;
                if (el.disabled) return;
                const raw = (el.value || '').trim();
                if (!raw) {
                    el.classList.remove('is-invalid');
                    if (el.dataset.tipBase) el.dataset.tip = el.dataset.tipBase;
                    return;
                }
                const ok = pointRegex.test(raw);
                if (!el.dataset.tipBase && el.dataset.tip) el.dataset.tipBase = el.dataset.tip;
                if (ok) {
                    el.classList.remove('is-invalid');
                    if (el.dataset.tipBase) el.dataset.tip = el.dataset.tipBase;
                } else {
                    el.classList.add('is-invalid');
                    el.dataset.tip = '坐标格式不正确：示例 (1600,1600) 或 1600,1600';
                }
            };

            document.addEventListener('input', (e) => {
                const el = e.target;
                if (!el || !el.matches) return;
                if (el.matches('input[data-point="1"]')) {
                    validatePointInput(el);
                }
            }, true);

            document.querySelectorAll('input[data-point="1"]').forEach(validatePointInput);

            // C：结果区悬浮快捷操作与复制
            const resultContainer = document.getElementById('resultContainer');
            const actionsEl = document.getElementById('resultActions');
            const copyStartBtn = document.getElementById('copyStartTimeBtn');
            const copyOffsetBtn = document.getElementById('copyOffsetBtn');
            let activeRow = null;

            const hideActions = () => {
                if (!actionsEl) return;
                activeRow = null;
                actionsEl.dataset.show = 'false';
                actionsEl.style.transform = 'translate3d(-9999px, -9999px, 0)';
            };

            const positionActions = () => {
                if (!actionsEl || !resultContainer || !activeRow) return;
                const rowRect = activeRow.getBoundingClientRect();
                const contRect = resultContainer.getBoundingClientRect();
                const actionsRect = actionsEl.getBoundingClientRect();
                const pad = 10;
                let x = (rowRect.right - contRect.left) - actionsRect.width - pad;
                let y = (rowRect.top - contRect.top) + 6;
                if (x < pad) x = pad;
                if (y < pad) y = pad;
                actionsEl.style.transform = `translate3d(${Math.round(x)}px, ${Math.round(y)}px, 0)`;
            };

            if (resultContainer && actionsEl) {
                const coarsePointer = window.matchMedia && window.matchMedia('(pointer: coarse)').matches;
                const hoverCapable = Boolean(window.matchMedia && window.matchMedia('(any-hover: hover)').matches);
                const useHover = hoverCapable;

                if (useHover) {
                    // 桌面端：悬停出现
                    resultContainer.addEventListener('pointerover', (e) => {
                        const tr = e.target && e.target.closest ? e.target.closest('#resultBody tr') : null;
                        if (!tr) return;
                        if (tr.dataset.copyable !== '1') {
                            hideActions();
                            return;
                        }
                        activeRow = tr;
                        actionsEl.dataset.show = 'true';
                        requestAnimationFrame(positionActions);
                    });

                    resultContainer.addEventListener('pointermove', () => {
                        if (!activeRow) return;
                        requestAnimationFrame(positionActions);
                    });

                    resultContainer.addEventListener('pointerleave', hideActions);
                    window.addEventListener('scroll', hideActions, true);
                } else {
                    // 移动端：点击行出现（无 hover）
                    resultContainer.addEventListener('click', (e) => {
                        const tr = e.target && e.target.closest ? e.target.closest('#resultBody tr') : null;
                        if (!tr) return;
                        if (tr.dataset.copyable !== '1') {
                            hideActions();
                            return;
                        }
                        activeRow = tr;
                        actionsEl.dataset.show = 'true';
                        requestAnimationFrame(positionActions);
                    }, true);

                    document.addEventListener('click', (e) => {
                        if (!resultContainer.contains(e.target) && !actionsEl.contains(e.target)) {
                            hideActions();
                        }
                    }, true);
                    window.addEventListener('scroll', hideActions, true);
                }
            }

            if (copyStartBtn) {
                copyStartBtn.addEventListener('click', async () => {
                    if (!activeRow) return;
                    const text = activeRow.dataset.startTime || '';
                    const ok = await copyText(text);
                    showToast(ok ? '已复制：出发时间' : '复制失败：请手动选择复制');
                });
            }

            if (copyOffsetBtn) {
                copyOffsetBtn.addEventListener('click', async () => {
                    if (!activeRow) return;
                    const text = activeRow.dataset.offset || '';
                    const ok = await copyText(text);
                    showToast(ok ? '已复制：落点偏移' : '复制失败：请手动选择复制');
                });
            }

            // 自定义霓虹提示：读取 data-tip，鼠标悬停时显示（事件委托，动态新增的控件也能自动生效）
            // 注意：综合 any-hover / pointer:fine / hoverNone，避免误判导致提示完全失效
            if (tooltipEl && canHover) {
                let activeEl = null;
                let rafPending = false;

                const hideTooltip = () => {
                    activeEl = null;
                    tooltipEl.setAttribute('aria-hidden', 'true');
                    tooltipEl.dataset.show = 'false';
                    tooltipEl.style.transform = 'translate3d(-9999px, -9999px, 0)';
                };

                const showTooltip = (el) => {
                    const tip = el.getAttribute('data-tip');
                    if (!tip) return;
                    activeEl = el;
                    tooltipEl.textContent = tip;
                    tooltipEl.setAttribute('aria-hidden', 'false');
                    tooltipEl.dataset.show = 'true';
                    schedulePosition();
                };

                const schedulePosition = () => {
                    if (rafPending) return;
                    rafPending = true;
                    requestAnimationFrame(() => {
                        rafPending = false;
                        if (!activeEl || tooltipEl.dataset.show !== 'true') return;

                        const pad = 10;
                        const gap = 10;
                        const viewportW = window.innerWidth;
                        const viewportH = window.innerHeight;
                        const a = activeEl.getBoundingClientRect();
                        const t = tooltipEl.getBoundingClientRect();

                        // 默认放在控件上方居中；如果空间不够则放下方
                        let place = 'top';
                        let x = a.left + (a.width / 2) - (t.width / 2);
                        let y = a.top - t.height - gap;
                        if (y < pad) {
                            place = 'bottom';
                            y = a.bottom + gap;
                        }

                        // 左右边界约束
                        if (x < pad) x = pad;
                        if (x + t.width + pad > viewportW) x = viewportW - t.width - pad;

                        // 下边界约束（极端情况兜底）
                        if (y + t.height + pad > viewportH) y = viewportH - t.height - pad;

                        // 箭头位置对准控件中心
                        const centerX = a.left + a.width / 2;
                        const arrowX = Math.max(12, Math.min(t.width - 12, centerX - x));
                        tooltipEl.style.setProperty('--arrowX', `${Math.round(arrowX)}px`);
                        tooltipEl.dataset.place = place;
                        tooltipEl.style.transform = `translate3d(${Math.round(x)}px, ${Math.round(y)}px, 0)`;
                    });
                };

                document.addEventListener('pointerover', (e) => {
                    const el = e.target && e.target.closest ? e.target.closest('[data-tip]') : null;
                    if (!el) return;
                    showTooltip(el);
                }, true);

                document.addEventListener('pointermove', (e) => {
                    if (!activeEl) return;
                    schedulePosition();
                }, true);

                document.addEventListener('pointerout', (e) => {
                    if (!activeEl) return;
                    const leavingFrom = e.target && e.target.closest ? e.target.closest('[data-tip]') : null;
                    const enteringTo = e.relatedTarget && e.relatedTarget.closest ? e.relatedTarget.closest('[data-tip]') : null;
                    if (leavingFrom && enteringTo && leavingFrom === enteringTo) return;
                    hideTooltip();
                }, true);

                document.addEventListener('scroll', hideTooltip, true);
                window.addEventListener('blur', hideTooltip);
                window.addEventListener('resize', () => {
                    if (!activeEl) return;
                    schedulePosition();
                });
            }

            // 指针光晕：跟随鼠标位置（纯视觉）
            if (cursorGlow && !hoverNone) {
                const setCursorGlow = (x, y) => {
                    cursorGlow.style.setProperty('--cgx', `${x}px`);
                    cursorGlow.style.setProperty('--cgy', `${y}px`);
                };

                document.addEventListener('pointermove', (e) => {
                    setCursorGlow(e.clientX, e.clientY);
                }, { passive: true });

                document.addEventListener('pointerleave', () => {
                    setCursorGlow(-9999, -9999);
                });

                // 更稳：鼠标离开浏览器窗口时隐藏光晕
                window.addEventListener('mouseout', (e) => {
                    if (!e.relatedTarget && !e.toElement) {
                        setCursorGlow(-9999, -9999);
                    }
                });
            }

            // 面板 3D 倾斜：根据鼠标位置微调（输入时自动关闭）
            if (false && containerEl && !hoverNone && !prefersReduce) {
                const maxDeg = 6;
                let rafTilt = 0;
                let px = 0;
                let py = 0;

                const applyTilt = () => {
                    rafTilt = 0;
                    if (containerEl.matches(':focus-within')) {
                        containerEl.removeAttribute('data-tilt');
                        containerEl.style.removeProperty('--rx');
                        containerEl.style.removeProperty('--ry');
                        return;
                    }

                    const r = containerEl.getBoundingClientRect();
                    const cx = r.left + r.width / 2;
                    const cy = r.top + r.height / 2;
                    const dx = (px - cx) / (r.width / 2);
                    const dy = (py - cy) / (r.height / 2);

                    const rx = (Math.max(-1, Math.min(1, -dy)) * maxDeg).toFixed(2);
                    const ry = (Math.max(-1, Math.min(1, dx)) * maxDeg).toFixed(2);
                    containerEl.setAttribute('data-tilt', '1');
                    containerEl.style.setProperty('--rx', `${rx}deg`);
                    containerEl.style.setProperty('--ry', `${ry}deg`);
                };

                containerEl.addEventListener('pointermove', (e) => {
                    px = e.clientX;
                    py = e.clientY;
                    if (rafTilt) return;
                    rafTilt = requestAnimationFrame(applyTilt);
                });

                containerEl.addEventListener('pointerleave', () => {
                    containerEl.removeAttribute('data-tilt');
                    containerEl.style.removeProperty('--rx');
                    containerEl.style.removeProperty('--ry');
                });
            }

            // 使用教程弹窗（纯交互增强，不影响原计算逻辑；支持遮罩关闭/ESC关闭）
            if (guideBtn && guideModal && guideBackdrop && guideClose) {
                const openGuide = () => {
                    guideModal.dataset.open = 'true';
                    guideModal.setAttribute('aria-hidden', 'false');
                    document.body.classList.add('guide-open');
                    if (tooltipEl) {
                        tooltipEl.setAttribute('aria-hidden', 'true');
                        tooltipEl.dataset.show = 'false';
                        tooltipEl.style.transform = 'translate3d(-9999px, -9999px, 0)';
                    }
                    try { guideClose.focus(); } catch (e) {}
                };

                const closeGuide = () => {
                    guideModal.dataset.open = 'false';
                    guideModal.setAttribute('aria-hidden', 'true');
                    document.body.classList.remove('guide-open');
                };

                guideBtn.addEventListener('click', openGuide);
                guideClose.addEventListener('click', closeGuide);
                guideBackdrop.addEventListener('click', closeGuide);
                window.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape' && guideModal.dataset.open === 'true') closeGuide();
                });
            }

            // 背景音乐：仅支持选择本地音频文件播放（避免版权风险；也符合浏览器自动播放限制）
            if (bgmBtn && bgmFile && bgmAudio) {
                let objUrl = '';
                const savedVol = Number(localStorage.getItem('bgmVolume'));
                bgmAudio.volume = Number.isFinite(savedVol) ? Math.max(0, Math.min(1, savedVol)) : 0.35;

                const ensureSelected = () => {
                    if (bgmAudio.src) return true;
                    try { bgmFile.value = ''; } catch (e) {}
                    bgmFile.click();
                    showToast('请选择本地音频文件（mp3/wav/flac等）');
                    return false;
                };

                const togglePlay = async () => {
                    if (!ensureSelected()) return;
                    if (bgmAudio.paused) {
                        try {
                            await bgmAudio.play();
                            showToast('背景音乐：播放中');
                        } catch (e) {
                            showToast('背景音乐播放失败：请再次点击或更换音频');
                        }
                    } else {
                        bgmAudio.pause();
                        showToast('背景音乐：已暂停');
                    }
                };

                bgmBtn.addEventListener('click', togglePlay);
                bgmFile.addEventListener('change', () => {
                    const f = bgmFile.files && bgmFile.files[0];
                    if (!f) return;
                    try {
                        if (objUrl) URL.revokeObjectURL(objUrl);
                        objUrl = URL.createObjectURL(f);
                        bgmAudio.src = objUrl;
                        bgmAudio.play().then(() => {
                            showToast('背景音乐已载入并开始播放');
                        }).catch(() => {
                            showToast('背景音乐已载入：点击“背景音乐”开始播放');
                        });
                    } catch (e) {
                        showToast('背景音乐载入失败：请更换音频文件');
                    }
                });

                window.addEventListener('beforeunload', () => {
                    try { if (objUrl) URL.revokeObjectURL(objUrl); } catch (e) {}
                });
                bgmAudio.addEventListener('volumechange', () => {
                    try { localStorage.setItem('bgmVolume', String(bgmAudio.volume)); } catch (e) {}
                });
            }

            // 路径/队伍区：右侧“中转/出发”按钮用于折叠/展开（纯UI，不影响计算逻辑）
            const bindSectionToggle = (btn, bodyEl, label) => {
                if (!btn || !bodyEl) return;
                const apply = (collapsed) => {
                    bodyEl.dataset.collapsed = collapsed ? 'true' : 'false';
                    btn.setAttribute('aria-pressed', collapsed ? 'true' : 'false');
                    btn.setAttribute('data-tip', collapsed ? `点击展开：${label}` : `点击收起：${label}`);
                };
                apply(false);
                btn.addEventListener('click', () => {
                    const collapsed = bodyEl.dataset.collapsed === 'true';
                    apply(!collapsed);
                    showToast(!collapsed ? `已收起：${label}` : `已展开：${label}`);
                });
            };

            bindSectionToggle(toggleTransferBtn, transferSection, '中转曲点');
            bindSectionToggle(toggleTeamBtn, teamSection, '队伍出发点');
            bindSectionToggle(toggleInputBtn, inputSection, '坐标输入');
            bindSectionToggle(togglePreviewBtn, previewSection, '航线预览');
            bindSectionToggle(toggleResultBtn, resultSection, '输出结果');

            // 星空跃迁背景：canvas starfield（纯视觉，带 deltaTime 与后台暂停）
            if (starCanvas && !prefersReduce) {
                const ctxStar = starCanvas.getContext('2d');
                if (!ctxStar) return;

                let w = 0;
                let h = 0;
                let dpr = 1;
                let stars = [];
                let rafStar = 0;
                let running = true;
                let lastT = 0;

                const resize = () => {
                    dpr = window.devicePixelRatio || 1;
                    w = Math.max(1, window.innerWidth);
                    h = Math.max(1, window.innerHeight);
                    starCanvas.width = Math.floor(w * dpr);
                    starCanvas.height = Math.floor(h * dpr);
                    ctxStar.setTransform(dpr, 0, 0, dpr, 0, 0);

                    const count = Math.min(420, Math.max(240, Math.floor((w * h) / 5200)));
                    const depth = 900;
                    stars = new Array(count).fill(0).map(() => ({
                        x: (Math.random() - 0.5) * w,
                        y: (Math.random() - 0.5) * h,
                        z: Math.random() * depth + 1,
                        pz: 0
                    }));
                };

                const resetStar = (s) => {
                    const depth = 900;
                    s.x = (Math.random() - 0.5) * w;
                    s.y = (Math.random() - 0.5) * h;
                    s.z = depth;
                    s.pz = depth;
                };

                const tick = (t) => {
                    if (!running) return;
                    // 使用 deltaTime，避免高刷屏(120Hz/144Hz)导致速度过快
                    const dt = lastT ? Math.min(48, t - lastT) : 16.7;
                    lastT = t;
                    ctxStar.clearRect(0, 0, w, h);

                    const cx = w / 2;
                    const cy = h / 2;
                    const fov = 320;
                    const baseSpeed = 2.4;
                    const speed = (baseSpeed + 1.1 * (0.5 + 0.5 * Math.sin(t / 1600))) * (dt / 16.7);

                    for (let i = 0; i < stars.length; i++) {
                        const s = stars[i];
                        s.pz = s.z;
                        s.z -= speed;
                        if (s.z <= 1) {
                            resetStar(s);
                            continue;
                        }

                        const sx = cx + (s.x / s.z) * fov;
                        const sy = cy + (s.y / s.z) * fov;
                        const px = cx + (s.x / s.pz) * fov;
                        const py = cy + (s.y / s.pz) * fov;

                        if (sx < -50 || sx > w + 50 || sy < -50 || sy > h + 50) {
                            resetStar(s);
                            continue;
                        }

                        const a = Math.max(0.08, Math.min(0.85, 1 - s.z / 900));
                        ctxStar.strokeStyle = `rgba(236,245,255,${a})`;
                        ctxStar.lineWidth = Math.max(0.6, 1.6 * a);
                        ctxStar.beginPath();
                        ctxStar.moveTo(px, py);
                        ctxStar.lineTo(sx, sy);
                        ctxStar.stroke();
                    }

                    rafStar = requestAnimationFrame(tick);
                };

                const start = () => {
                    if (rafStar) return;
                    running = true;
                    lastT = 0;
                    rafStar = requestAnimationFrame(tick);
                };

                const stop = () => {
                    running = false;
                    if (rafStar) cancelAnimationFrame(rafStar);
                    rafStar = 0;
                };

                resize();
                window.addEventListener('resize', resize);
                document.addEventListener('visibilitychange', () => {
                    if (document.hidden) stop();
                    else start();
                });
                start();
            }
        })();
    </script>
</body>
</html>
